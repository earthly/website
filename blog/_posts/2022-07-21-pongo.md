---
title: "Put Your Best Title Here"
categories:
  - Tutorials
toc: true
author: Josh

internal-links:
 - just an example
---
Building Pong in your Terminal Part one

What you'll learn in this tutorial
    - How to create applications for the terminal
    - How to work with Go routines
    - A tiny bit about animation
    - A tiny bit about game dev

I just want to start by saying I barely know Go and I don't know anything about game development or design. I build this to learn! If you want a project to learn a more about concurrency in Go, building terminal UIs, or stumble through the very basics of Game dev, than you are in the right place.

I've been trying to learn Go recently and decided I'd try to build a version of Pong that would run entirely in the terminal. Previously, I wrote an article were [I built a contacts application in the terminal]() using the [tview](https://github.com/rivo/tview) package. This was a great first project to get me used to the some of what Go has to offer. After I was done, a colleague sent me a link to a list of [terminal games](https://www.tecmint.com/best-linux-terminal-console-games/), which got me interested in trying to build one myself. I'm no game designer, so I decided to try to rebuild something that would be relatively simple to figure out and reproduce, but still give me a chance to deepen my Go knowledge. That landed me on Pong.

Pong is simple. There are only three sprites on screen, the level is always the same, and the game logic is pretty simple to code. This also seemed like a great project to help me start to wrap my head around Go routines and Channels. Concepts that were completely new to me coming from Ruby/Python.

## Tcell vs Tview for Terminal Games

Originally I thought I would be able to use the tview package I'd used in my last article for this project. It has a grid system that I figured I could take advantage of to act as my game world, but that didn't turn out to be the case. I wanted to be able to access and update the exact x and y coordinates of elements in the terminal, and as far as I could tell, that wasn't easily possible in tview.

Depending on what kind of game you want to make, Tview could still be a great choice. It would work for games that don't have any animation like a [multiplayer chess](https://github.com/qnkhuat/gochess), a card game like black jack, or [dominos](https://github.com/gusti-andika/card-domino).

Tview is buildt on top of another Go package called [tcell](https://github.com/gdamore/tcell). "Tcell is a Go package that provides a cell based view for text terminals, like XTerm. It was inspired by termbox, but includes many additional improvements." Basically, tcell is going to allow us to interact with the terminal using Go code in a much more fine grained way than tview could.

## Hello Game World

Just to warn you, it's going to be a bit before we get to anything super fun. We'll need to take some baby steps toward our goal in order to fully understand how our game will work. This first article will get us up the point that we have a bouncing ball roaming the screen.

First, import tcell.

```go
import "github.com/gdamore/tcell/v2"
```

To get started, we create a tcell Screen. This represents the physical terminal screen. Tcell is set up to detect what type of terminal you are using and claims to have support for many types of terminals on Linux, Mac and Windows, so you shouldn't need to configure it after creation.

```go
func main() {

	screen, err := tcell.NewScreen()

	if err != nil {
		log.Fatalf("%+v", err)
	}
	if err := s.Init(); err != nil {
		log.Fatalf("%+v", err)
	}
}
```
Next, we can set a default style for our screen. This will set the foreground and background colors. It is possible to define colors as RGB values, hex values, or by using tcell's [color constants](https://pkg.go.dev/github.com/gdamore/tcell#section-readme). We can have some fun with this later.

To get started though, we'll use the constant `ColorReset` which just sets the tcell Screen defualts to whatever the terminal defaults are.

```go
defStyle := tcell.StyleDefault.Background(tcell.ColorBlack).Foreground(tcell.ColorBlack)
screen.SetStyle(defStyle)
```

Now, to write to the screen, we can use the `SetContent` function. This takes a number of arguments. First, it's going to need the X and Y values of each character you want to place on the screen. Then the character itself. We can only pass single Runes to `SetContent`, so to write "Hi!" we'll need three lines of code. 


```go
	screen.SetContent(0, 0, 'H', nil, defStyle)
	screen.SetContent(1, 0, 'i', nil, defStyle)
	screen.SetContent(2, 0, '!', nil, defStyle)
```

<div class="notice--info">
We could also write the same code above like this.
```go
s.SetContent(n, 10, '0', []rune{'i', '!'}, defStyle)
```

The docs don't show this and even say that the fourth argument will usually be `nil`. To write longer strings of text, the tcell tutorial recommends writing a [function](https://github.com/gdamore/tcell/blob/master/TUTORIAL.md?plain=1#L117) that loops over a string, calling `SetContent` for each character in the string.
</div>

## Imagine a Graph

{% picture content-wide-nocrop {{site.pimages}}{{page.slug}}/graph.jpg --alt {{x and y access }} %}
<figcaption>"In tcell, (0,0) is in the top left corner"</figcaption>

If you're not used to thinking about your screen as a graph with an X axis and a Y axis, you'll need to start. You may be used to graphs that start with (0,0) in the lower left hand corner. But Screens put (0,0) in the upper left. So when we run the code from the last section, we should see text to appear at the top of the screen.

Ok, but if we run this code, it appears as though nothing happens. That's because nothing we set up in `SetContent` get's dipslayed until we call `Show()` on our screen. 

```go
screen.Show()
```

Now if we run the code...still nothing. Well, the program did write 'Hi!' to the screen, but it then immediatley exited. Depending on your terminal settings, you may be able to scroll up and see the 'Hi!', but it doesn't matter. This is not what we want.

In order to fix this, we'll use an infinte loop.

```go
	for {

		screen.SetContent(0, 0, 'H', nil, defStyle)
		screen.SetContent(1, 0, 'i', nil, defStyle)
		screen.SetContent(2, 0, '!', nil, defStyle)

		screen.Show()
	}
```

Now if you run this you'll see "Hi!" written in your terminal. The loop is keeping our program running so it doesn't exit. It's also repeatedly writing "Hi!" to the screen. We can't tell because it's just overlapping itself, but "Hi!" is getting written over and over on top of itself. This is important to note for the next section.

Ok, press `escape` or `Ctrl + C` to exit.

Go ahead press it.

You're not pressing it right.

Oh wait...

## The Ability To Rage Quit

One of the most important features of any video game is the ability to get upset at it and then pound on your keyboard until it goes away. We can't quit our game yet because we need to set up some code that can read user input and react. For now, you can "quit" your program by closing your terminal window and opening a new one.

Tcell makes polling for events straight forward and simple. Make sure to put the following code **below** what we've written so far.

```go
	switch event := s.PollEvent().(type) {
		case *tcell.EventResize:
			s.Sync()
		case *tcell.EventKey:
			if event.Key() == tcell.KeyEscape || event.Key() == tcell.KeyCtrlC {
				screen.Fini()
				os.Exit(0)
			}
		}
```
We can use a switch case to react to different types of events. In the case above, we call `Sync` if the window get's resized. `Sync` works similar to `Show`, however, `Show` will try to update the screen in "the most efficient way possible", and `Sync` takes a more tear everything down and redraw it approach. Basically, with `Show`, you're not likely to notice it updating, which is why we use it in most cases. But when the screen is resized we need to completely redraw everything. Now we should be able to use `escape` or `Ctrl + C` to exit.

Next, we set up a case for any key press event. Within this case, we can set up another case to react to certain keys, or in this instance, we just use an if statement. `Fini()` tells our tcell screen to stop and close, and then we can gracefully exit our program. Don't forget to add `os` to your imports.

## Movement

Well now we have a program that says Hi! until you press esc. For the loneliest among us, that may be enough. But we came here to build a game, so we'll need some kind of animation. Let's see if we can get that "Hi!" to travel across the screen. The basic idea here is that, instead of setting a fixed value for our x position, we can set it to a variable. Then, each time through our infinite loop, we can incriment that variable. This will cause tcell to redraw "Hi!" at the new position at every iteration, making it appear to move across the screen. I've also changed the y coordinates to be 10, just to put "Hi!" in the middle and make it a little easier to see.

```go
  x := 0
    for {

		screen.SetContent(x, 10, 'H', nil, defStyle)
		screen.SetContent(x+1, 10, 'i', nil, defStyle)
		screen.SetContent(x+2, 10, '!', nil, defStyle)

		screen.Show()
		x++
		
		switch event := screen.PollEvent().(type) {
```

Run this and you'll be disappointed to see that we do not have a moving "Hi!". The problem here is our `PollEvent`. This function stops and waits for input, which means it's blocking us from getting to the next iteration of the loop. You can try to resize your window over and and over, and you'll see the Hi! move, but obviously we do not want that.

We can fix this by wrapping our logic in a function and then using a Go routine. Our function will need it's own event loop, since it will spin off to run alongside our main function. Then we can pass it the screen and the defaultStyle.

```go
func Run( screen tcell.Screen, defStyle tcell.Style) {
	x := 0
	for {

		screen.SetContent(x, 10, 'H', nil, defStyle)
		screen.SetContent(x+1, 10, 'i', nil, defStyle)
		screen.SetContent(x+2, 10, '!', nil, defStyle)

		screen.Show()

		x++
	}
}
```

And then call it in the main function and put our switch statement back to listen for events.

```go
	go Run(screen, defStyle)

	for {
		switch event := screen.PollEvent().(type) {
		case *tcell.EventKey:
			if event.Key() == tcell.KeyEscape || event.Key() == tcell.KeyCtrlC {
				screen.Fini()
				os.Exit(0)
			}
		}
	}

```
We are so close but if we run this, we'll just get a bunch of H's across the middle of our screen.

![H's]

I wanted to show this to illistrate two more concepts, but first let's understand what is happening here. Each time through the loop we are writing H to the screen at a new position. What we are not doing is deleting it from the old position. That's really all the animation effect is. An object being drawn to a position, then deleted and redrawn to another position right next to the old position. And then this process is repeated over and over again. What we are missing is the delete from the old position part, which we can add by calling `screen.Clear()` at the begining of every iteration.

```go
	for {
		screen.Clear()
		screen.SetContent(x, 10, 'H', nil, defStyle)
```
That will get rid of all the extra H's. But if we run this, now we'll just see a blank screen, which brings us to the other issue. Computers are way to fast for the naked eye. The program did what we wanted it to do, but the H flew across the screen before we could even see it. To fix this issue, we need to add delay between when we draw to the screen and when we clear it for the next frame of animation. We can easily do that by importing the time package. So here is our completed function.

```go
func Run(screen tcell.Screen, defStyle tcell.Style) {
	x := 0
	for {
		screen.Clear()
		screen.SetContent(x, 10, 'H', nil, defStyle)
		screen.SetContent(x+1, 10, 'i', nil, defStyle)
		screen.SetContent(x+2, 10, '!', nil, defStyle)

		screen.Show()
		x++

		time.Sleep(40 * time.Millisecond)

	}
}
```
Success! https://asciinema.org/a/JIl0zfc9NPxtGH5vPHVfXIRAe

<script zoom="2" id="asciicast-JIl0zfc9NPxtGH5vPHVfXIRAe" src="https://asciinema.org/a/2UWD3NMXowmPCfTlwYjyFDJSF.js" async data-loop="true"  data-fit="none" data-autoplay="true" data-speed="2" data-size="small" data-start-at=10 ></script>

## A Bouncing Ball

Ok so we took a long time to get here but a lot of these concepts, the screen is a graph, updating during our event loop, redrawing and reacting to input, will be used over and over as we develop the game from here.

Now we can start thinking about our code in terms of a game of Pong. We can start to break the game down into objects that we can set up via structs. For now we can think of the game as three parts.

- The Game
This will be the wrapper for all the game objects. It will hold the ball, the game field, the score, the player info etc.

- The Ball
The ball is the ball. It bounces around etc. It needs to hold the x and y value of the ball and it needs to define some behavior for the ball. What happens when it reaches the edge of the screen? What should it look like?

- The Main Function and Event Loop
This is where we will bring everything together and actually run our game.

Three pieces feels like three seperate files to me so going forward I've created a `game.go` and a `ball.go` in addition to my `main.go`.

Start by creating a Game struct. For now, all it needs is a screen. We could also call think the game world, but since we've been calling it a screen up until this point, we'll stick with screen.

```go
type Game struct {
	Screen tcell.Screen
}
```

Then we are going to create a function to run our game. We'll move everything from our previous `Run` function in here. I've also moved the `defStyle` in here.

```go
func (g *Game) Run() {
	
	defStyle := tcell.StyleDefault.Background(tcell.ColorDefault).Foreground(tcell.ColorDefault)
	g.screen.SetStyle(defStyle)

	x := 0
	for {
		g.screen.Clear()
		g.screen.SetContent(x, 10, 'H', nil, defStyle)
		g.screen.SetContent(x+1, 10, 'i', nil, defStyle)
		g.screen.SetContent(x+2, 10, '!', nil, defStyle)

		g.screen.Show()
		x++

		time.Sleep(40 * time.Millisecond)

	}

}
```
Now, in our main function, we can update it to look like this.

```go
func main() {

	screen, err := tcell.NewScreen()

	if err != nil {
		log.Fatalf("%+v", err)
	}
	if err := screen.Init(); err != nil {
		log.Fatalf("%+v", err)
	}

	game := Game{
		screen: screen,
	}

	go game.Run()

	for {
		switch event := screen.PollEvent().(type) {
		case *tcell.EventKey:
			if event.Key() == tcell.KeyEscape || event.Key() == tcell.KeyCtrlC {
				screen.Fini()
				os.Exit(0)
			}
		}
	}

}
```
This should run exactly as it did before. All we've done is plan ahead a little and refactor.

## The Ball

Create a new file `ball.go`. 

```go
type Ball struct {
	X      int
	Y      int
}
```
And then we'll need a function to display our ball. In this case I'm using the 

```go
func (b *Ball) Display() rune {
	return '\u25CF'
}
```

### Movement

Before we were causing our "Hi!" to move across the screen by adding to its X coordinate over and over in our loop. We want this behavior to be part of our ball. We also want to give it the ability to move along the Y axis as well. So we need a variable that we can incriment by over and over. We can call this the balls "Speed". First, add variables for both Xspeed and Yspeed.

```go
type Ball struct {
	X      int
	Y      int
	Xspeed int
	Yspeed int
}
```
Then, add a function that updates the ball's postion.

```go
func (b *Ball) Update() {
	b.X += b.Xspeed
	b.Y += b.Yspeed
}
```

Ok, now, in our main function, we want to add the Ball to our Game.

```go
	ball := Ball{
		X:      1,
		Y:      1,
		Xspeed: 1,
		Yspeed: 1,
	}

	game := Game{
		Screen: screen,
		Ball:   ball,
	}

```

Then in we can update the for loop in our `Run` function to use the ball.

```go
	for {

		s.Clear()

		g.Ball.Update()

		s.SetContent(g.Ball.X, g.Ball.Y, g.Ball.Display(), nil, defStyle)

		time.Sleep(40 * time.Millisecond)
		s.Show()
	}

```

Run this and you'll see the ball flying across the screen at an angle! Until it reaches the edge and vanishes forever.

The reason is, when we update the x and y of the Ball, we just keeping adding to it. The ball doesn't know it's reached the edge of the screen, it just keeps going. We need to add logic to our ball so that it will "bounce" whenever it reaches the edge of the terminal window. Tcell can provide us with the max width and height of the terminal window. So we need to create a function that reverses the direction of the ball whenever it reaches an edge.

```go
func (b *Ball) CheckEdges(maxWidth int, maxHeight int) {
	if b.X <= 0 || b.X >= maxWidth {
		b.Xspeed *= -1
	}

	if b.Y <= 0 || b.Y >= maxHeight {
		b.Yspeed *= -1
	}
}
```

We can tell if the ball has reached an edge when its position is either less than zero, or more than the maxHeight or maxWidth of the window. When it's position is greater than the max, we want to start subtracting, to send it back in the other direction. When the position is less than zero, we want to start adding to it again.

A quick way to switch between adding and subtracting is to change the speed variable to from positive to negative. (Might need some images here.)

With this in place we can call this function in `Run`. We can easily get the width and height from the screen.

```go
// inside the for loop in the Run function
	width, height := screen.Size()
	g.Ball.CheckEdges(width, height)
```

And that should be it. We finally have our bouncing ball. Now all you'll need to do is replace the ball with the DVD logo. Or, you can wait until our next post when we'll add paddles, a score, players and try to get this thing looking like a game.

### Writing Article Checklist

- [ ] Write Outline
- [ ] Write Draft
- [ ] Fix Grammarly Errors
- [ ] Read out loud
- [ ] Write 5 or more titles and pick the best on
- [ ] First two paragraphs: What's it about? Why listen to you?
- [ ] Create header image in Canva
- [ ] Optional: Find ways to break up content with quotes or images
- [ ] Verify look of article locally
- [ ] Run mark down linter (`lint`)
- [ ] Add keywords for internal links to front-matter
- [ ] Run `link-opp` and find 1-5 places to incorporate links to other articles
- [ ] Add Earthly `CTA` at bottom `{% include cta/cta1.html %}`
- [ ] Raise PR

