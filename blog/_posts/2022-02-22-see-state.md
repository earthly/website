---
title: "Seeing Like an Architect"
categories:
  - Articles
author: Adam
featured: true
sidebar:
  nav: "thoughts"
---
### Writing Article Checklist

- [ ] Write Outline
- [ ] Write Draft
- [ ] Fix Grammarly Errors
- [ ] Read out loud
- [ ] Write 5 or more titles and pick the best on
- [ ] First two paragraphs: What's it about? Why listen to you?
- [ ] Create header image in Canva
- [ ] Optional: Find ways to break up content with quotes or images
- [ ] Verify look of article locally
- [ ] Run mark down linter (`lint`)
- [ ] Add keywords for internal links to front-matter
- [ ] Run `link-opp` and find 1-5 places to incorporate links to other articles
- [ ] Add Earthly `CTA` at bottom `{% include cta/cta1.html %}`
- [ ] Raise PR

## Queueng Solutions

Here is a simplification of a true story. 

A service that processes data input is struggling under increased load. Some clients are never getting their results, because other busier clients are clogging up the queue and starving them out. The problem is like operating system scheduling problem but in a micro-services, distributed system context and its causing problems. The worst kind of problems, the kind where the problem has bubbled up to an executive at the customer company who's never used the system and he starts making phone calls.

In turns out this system used a combination of a postgres table and Kafka topics for scheduling. Calls go out for who can help with this system and turns the people who do similar work on other systems in the aren't familar with Kafka. Best to just let the people who know the system work to improve it.

The problem resolves itself, but in the efforts of preventing this from happening in the future someone on the architecture team starts investigating how queing and work in progress is handled among hundred plus services at the company. It turns the answer is all of the possible ways: but mainly SQS, a database table, or Kafka. 

So a solution was proposed. A common library will be created and you can use it for all your queuing and message processing needs. It will be backed by Kafka and everybody will move to it.

The beauty of this solution is that everything will work the same. If one team working on what product solves some work starving problem, others can use the solution, because its a common lib and if things go wrong in one area, people from other areas can lend a hand, because its all the same solution everywhere.

It will look like this


Ok Wait, that part was a lie. The diagram looks pretty, at ground level working on a service that pulled some work from a SQS queue and now had to move to Kafka was a big change. I think picking Kafka was a tactical error here, because its a bad fit for being a work queue, but that isn't the point because even using postgres as a queue and moving to SQS changes the semantics a little bit. You can no longer de-queue and update the database in the same transaction. 

The actual problem was this: 

So what happened here was this:

1) Someone noticed something was complex
2) They took the time to map out how it was all working in a giant architecture diagram.
3) This diagram was a mess. Different services doing things all over the place.
4) The solution being messy was determined to be the problem.

   If there weren't many different ways to handle processing stuff then things would be easier. We could come up with some common ways to do things, put it in some shared code and things would move faster because there would be less work.

The problem is step four. The architecture diagrams goal was to help people understand how the various did things. It was a map, but there no reason to think that making the map more legible would fix a problem. The only problem it would fix would be to make it more understandable what was going on. There was no reason to think it would actually make the work easier.

There is actually a great book written about this type of decision making error. Seeing like a state. 

## Seeing Like a State

"Seeing like a state - How certain schemes to improve the human condition have failed" is about one thing: how centrally planned, top down scheme to improve the world have failed and if you squint they all have a lot in common and sound exactly like this 'unify the queues' effort.

### Scientify Forestry

In the 1800s, in Europe, forests were important sources of revenue. A tree could be timber and a tree could be firewood and each acre of forest was valuable. But how valuable? 

The problem with an acre of forests is it contains random trees in a random pattern. Its illegible. You can't really understand at high level what trees you have. You could make a map of it, but it would be hard and the map would be very complex. There a different types of trees, and even things that arent' tree strewn around randomly. 

<<map of random trees>>

So the solution was scientific forestry. Let's make a map of a simplified forest, where it just has the best type of tree and we'll make the whole forest that. It turns out the best tree was a norway spruce. 

This went poorly:
> The impoverished ecosystem couldnâ€™t support the game animals and medicinal herbs that sustained the surrounding peasant villages, and they suffered an economic collapse. The endless rows of identical trees were a perfect breeding ground for plant diseases and forest fires. And the complex ecological processes that sustained the soil stopped working, so after a generation the Norway spruces grew stunted and malnourished. [^1]

And you would think that would end things, but central planning things in a way that looks very uniform on a diagram but doesn't work well in practise continues to this day. City's once having a mixtures of crowded shops and houses and work places could be replaced with a grid plan city with all the retail in one location and residential areas in another.

James C. Scott calls systems like this legible. They are very easy to explain at a high level. How does work get processed in that service? The same was as in every other service. What type of tree is that in the forest? It is a norway spruce, same as all the other trees.

The problem is this reaching for legibility makes things easier to understand from a top down level, but the only problem it solves is one of easing top down control. 

## This is Hard

Seeing like a State goes through a lot of examples of this problem and he has words to convery certain approachs to problem solving (techne, metis, ...) but the summary is standaridization, especially top down standarization usually goes wrong in the same way. Trying to make the territory match a map and forgetting the map ( or archteture diagram ) is just a map. There are many local conditions on the ground that aren't reflected in the map.

I don't mean to say this a silly mistake no one should make. It's easy to make. If you go out to understand the way N number of services handle work in progress there is a lot of details. The way we as humans make sense of these things is abstract and group things together. What is common between how all these services do things? You build up an understanding and then with that understanding you try to come up with a solution.

I think the problem might be related to coming up with a global solution. Going back to the queue example, If the architect or senior++ principle engineer instead embedded with a team, and worked to solve that specific problem, and then another specific problem some commonalities may have emerged. Embedding with specific teams you get to learn the conditions on the ground. Lots of it doens't matter, but some of it does.

### Domain Driven Garbage

Once I noticed this pattern, in seeing like a state I started noticing how often it had occured. Years ago I worked on large monolithic system where the rate of change had started to slow down. So some very smart people took a look at it and decided that the problem was it didn't follow DDD princinples. The business logic and the retrival logic and whatever other areas all needed to be kept seperate. The 'domain' was mapped out and changes were made.

Now I had read part of DDD book, and I thought it was pretty good. It was all about representing the concepts within your problem domain in the code. But I must have read it wrong, because the local experts interpreted it as being about representing the concepts of DDD within your code. Everything was an XEntity or XRepository or something called an Aggregate, which, according to wikipedia is either sand, gravel or crushed stone. I don't know.

However, I hit a problem with this when my team had to build something that needed data from two areas. Because of seperation of data retrival and business logic to get 100 rows of data required 101 requests. This is the classic N+1 problem and there are solutions to it. 

But the people with the domain glossary thought the problem was I was trying to cross bounded contexts, whatever that means, and you weren't supposed to do that. It's the same problem again. They were looking at the map and using it to point out a mistake in the territory, not realizing they had the arrow backwards.

Anyways, no one involved in any of these discussions was an idiot. They were just disconneted from what was happening on the ground. They were focused on a global top down view, not realizing that their understanding could be wrong - it was just a simplification.

So, top down standardization bad, collaboritive temporailly embedded experts good.
