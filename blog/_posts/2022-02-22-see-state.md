---
title: "Put Your Best Title Here"
categories:
  - Tutorials
toc: true
author: Adam

internal-links:
 - just an example
---
### Writing Article Checklist

- [ ] Write Outline
- [ ] Write Draft
- [ ] Fix Grammarly Errors
- [ ] Read out loud
- [ ] Write 5 or more titles and pick the best on
- [ ] First two paragraphs: What's it about? Why listen to you?
- [ ] Create header image in Canva
- [ ] Optional: Find ways to break up content with quotes or images
- [ ] Verify look of article locally
- [ ] Run mark down linter (`lint`)
- [ ] Add keywords for internal links to front-matter
- [ ] Run `link-opp` and find 1-5 places to incorporate links to other articles
- [ ] Add Earthly `CTA` at bottom `{% include cta/cta1.html %}`
- [ ] Raise PR

## Draft.dev Article Checklist

- [ ] Add in Author page
- [ ] Create header image in Canva
- [ ] Optional: Find ways to break up content with quotes or images
- [ ] Verify look of article locally
  - Would any images look better `wide` or without the `figcaption`?
- [ ] Run mark down linter (`lint`)
- [ ] Add keywords for internal links to front-matter
- [ ] Run `link-opp` and find 1-5 places to incorporate links
- [ ] Add Earthly `CTA` at bottom `{% include cta/cta1.html %}`

## Intro

I go to a meeting and we are shown a diagram that looks like this.

And then my diagram that looks like this, and the first diagram is just, um, like a chaos spiderweb of things, connecting to things.

And then the second one has like four layers. And all the arrows kind of travel same direction.

And like, there was a detailed explanation about how this process would happen and how it would take a long time. Um, but basically all the services and the company were way too divergent. They all did things in different. And there was a plan to move from diagram one to diagram two. I think it's a good idea.

Really. You know, if a lot of services, deuce, similar things, like there's no reason, um, that they all have to be so different, right? Like there's commonalities that can be shared and all the services that makes sense. Um, But there is a problem with this diagram
That's the problem. Isn't that the problem isn't that there is nothing wrong with the structure.

The problem isn't that we're moving from one thing to another,

the problem had to do with legibility.

At the end of this process, uh, which may never complete the overall structure of all the services will be much more legible. It would be much easier for may.

From a high perspective to

pause this, no, from, from a top-down perspective would be much easier to understand how things worked. That it reminds me of this thing about the trains in Europe. 

## Trains In France

Here's the trains in Germany here is the trains. So if you pick any, any two points, um, in France, it's easy to know how to get from one to the other.

Right? You go to the nearest train station, go to Paris and then head to your destination. And it's classical, like hub and spoke. Um, you know, the, the systems of Germany or whatever were much more chaotic and, and kind of evolved over time, but no central planning,

but the system in France failed,

it failed the word lawyer to. When the Germans went to attack one city and they sent all the soldiers there. Um, and then since all the soldiers were there, the Germans just headed a little bit, uh, laterally towards the, the border on their trains and for the French, they, it would take them forever to make that.

## Queiing Solutions

Another solution I have heard of. There was a whole bunch of services, maybe 200 I don't know, but some used SQS and some used Kafka, there may have been other solutions in there as well, I don't recall.

But this was complex, and when people needed to do things that touched the queuing areas it took a long time. So the various way various queueing stuff was examined and a solution was proposed. 

A common library that simplified queueing stuff would be created and everyone would use that. That lib would do everything on Kafka. So all the people who used SQS to queue work now had to move to Kafka and this lib.  

<< Side note>>
Not the point of this story, but I think this was a tactical error here. Turns out that a work queue is exactly not what you should use Kafka for.

So this process did not go well. I did one of these SQS to Kafka moves and it went alright, but it was basically complicated overkill. 
<<>>

So what happened here was this:

1) someone noticed something was really complex
2) They took the time to map out how it was all working in a giant architecture diagram.
3) This diagram was a mess. Different services doing things all over the place.
4) The solution being messy was determined to be the problem.
   If there weren't many different ways to handle processing stuff then things would be easier. We could come up with some common ways to do things, put it in some shared code and things would move faster because there would be less work.


The problem is step four. The architecture diagrams goal was to help people understand services. It was a map but there no reason to think that making the map more legible would fix a problem. The only problem it would fix would be to make it more understanable what was going on. There was no reason to think it would actually make the work easier.

## Fungibility 

## This is Hard
I don't mean to say this a silly mistake no one should make. It's easy to make. If you go out to understand the way N number of services handle work in progress there is a lot of details. The way we as humans make sense of these things is abstract and group things together. What is common between how all these services do things. You build up an understanding and then with that understanding you try to come up with a solution. 

I think the problem might be the global solution. Instead if you had found a couple instances that seems more similar to each other and embedded with them and tried to help them you might end up in a better place. Embedding with specific teams you get to learn the conditions on the ground. Lots of it doens't matter, but some of it does. 

### Domain Driven Garbage

Once I noticed this pattern, in seeing like a state I started noticing how often it had occured. Years ago I worked on large monolithic system where the rate of change had started to slow down. So some very smart people took a look at it and decided that the problem was it didn't follow DDD princinples. The business logic and the retrival logic and whatever other areas all needed to be kept seperate.

However, I hit a problem with this when my team had to build a screen where tables of data were shown, and because of this seperation of data retrival and business logic and display to show 100 rows in the table 101 requests had to be made to the business layer section of code. This is the classic N+1 problem.

Now I had read part of DDD book, and I thought it was pretty good. It was all about representing the concepts within your problem domain in the code. But I must have read it wrong, because the local experts interpreted it as being about representing the concepts of DDD within your code. Everything was an XEntity or XRepository or something called an Aggregate, which, according to wikipedia is either sand, gravel or crushed stone. I don't know.

Anyways, no one involved in any of these discussions was an idiot. They were just disconneted from what was happening on the ground. They had a map of the business domain and they were giving advice from that, not realizing that the map could be wrong - it was just a simplicatfication.

Question: Ok, for each row we are showing we need this data from here, and then this data from here. And to combine these two we need to make a request per row, which takes so long the client request times out, so how do we do this in this new DDD world?

Answer: The problem is you are trying to cross bounded contexts.

Question: Ok, so how do I cross bounded context? 

Answer: You don't.



