---
title: "Building Pong in Your Terminal: Part Two"
categories:
  - Tutorials
toc: true
author: Josh

internal-links:
 - just an example
---

Let's start by adding Paddles. One should do to get us going. Let's create a file called `paddle.go`. Our paddle will be similar to our ball in that it will need an X and a Y position, and also a speed. We'll only be moving the paddles along the Y axis so for now we'll just set up a Yspeed. (Spoiler, we are going to replace most of this code later.)

```go
package main

type Paddle struct {
	X      int
	Y      int
	Yspeed int
}
```

Then we need to update our game struct to use the paddles. For now, our players will be paddles.

```go
type Game struct {
	Screen tcell.Screen
	Ball   Ball
	Player1 Paddle
	Player2 Paddle
}
```
And then we can create paddles and add them to our instance of Game inside our `main.go` file. Note we need to get the screen width in order to place the right paddle.

```go
	width, _ := s.Size()

	player1 := Paddle {
        width:  1,
        height: 6,
        Y:      3,
        X:      5,
        Yspeed: 3,
	}

	player2 := Paddle {
        width:  1,
        height: 6,
        Y:      3,
        X:      width - 5,
        Yspeed: 3,
	}

    game := Game{
		Screen:  s,
		Ball:    ball,
        Player1: player1,
		Player2: player2,
	}
```

Also similar to our ball, we'll need a way to display the paddle. **But this presents a problem**. Moving forward, let's choose to get excited by problems. Deal? Good, because this actually presents a bunch of problems. We'll tackle them one at a time. First, a quick review of how our ball object works.

Here is the code to display the ball:

```go
func (b *Ball) Display() rune {
	return "\u25CF"
}
```
It returns the unicode for a round dot that looks like the ball from Pong. Then, in our event loop in our `game.go` file, we can use the `tcell.Screen` to display it.

```go
	screen.SetContent(g.Ball.X, g.Ball.Y, g.Ball.Display(), nil, defStyle)
```
Remember that `SetContent` can only display one character at a time. No problem for our ball.
The problem is that our paddle isn't going to be one character. It needs to be several characters stacked on top of each other. Specifically, we want to use this character, &#x2588; , but multiple times. With our current setup, that would look something like this:

```go
	screen.SetContent(g.Paddle.X, g.Paddle.Y, g.Paddle.Display(), nil, defStyle)
	screen.SetContent(g.Paddle.X, g.Paddle.Y + 1, g.Paddle.Display(), nil, defStyle)
	screen.SetContent(g.Paddle.X, g.Paddle.Y + 2, g.Paddle.Display(), nil, defStyle)
	screen.SetContent(g.Paddle.X, g.Paddle.Y + 3, g.Paddle.Display(), nil, defStyle)
	screen.SetContent(g.Paddle.X, g.Paddle.Y + 3, g.Paddle.Display(), nil, defStyle)
```
No thank you.

To help us with this, and really anything we want to display that is larger than one character, we'll use a function. Luckily, the [tcell tutorial](https://github.com/gdamore/tcell/blob/master/TUTORIAL.md) offers a solution. In the form of this function. All I did was change the name. 

```go
func drawSprite(s tcell.Screen, x1, y1, x2, y2 int, style tcell.Style, text string) {
	row := y1
	col := x1

	for _, r := range []rune(text) {
		s.SetContent(col, row, r, nil, style)
		col++
		if col >= x2 {
			row++
			col = x1
		}
		if row > y2 {
			break
		}
	}
}
```

All this does is loop through a string and call `SetContent` for us on each character. I want to point out that we have two sets of coordinates. The first, x1 and y1, are like our starting position. The next set, x2 and y2, are where we want to end up. Moving forward, we can think of this as our width and our height for whatever we want to print to the screen. So with this in place, I can tell this function "Draw my paddle at position (2,3) and make it 1 character long and 7 characters high." This will make more sense as we go.

Let's take a look at a couple examples, because I think this interesting to understand, and I'm hoping someone more creative than me can come up with a better way to use this.

With this method, we still need to define our objects as one long string. We can use spaces along with a width and height to turn the string into a shape. So for example, I can make a house like this:

```go
```

## A Paddle, For Real This Time

This new setup isn't perfect, we'll need to do a couple of weird things to get it to work for us, but it's a huge improvement over calling `SetContent()` a bunch of times. Back in `paddle.go`, add the following:

```go
import strings

type Paddle struct {
    width  int
    height int
	X      int
	Y      int
	Yspeed int
}

func (p *Paddle) Display() string {
	return strings.Repeat("\u2588", p.height)
}
```

We've added a `width` and a `height` attribute to our struct, then we use it to determine how tall our paddle should be. Not that this alon will just return all the square characters in a long row like this:  &#x2588;&#x2588;&#x2588;&#x2588;. We'll need to tell `drawSprite` how to display it properly.

```go
    // repeat this for Player 2
    drawSprite(s,
			g.Player1.X,
			g.Player1.Y,
			g.Player1.X+g.Player1.width,
			g.Player1.Y+g.Player1.height,
			defStyle,
			g.Player1.Display())

```
{% picture content-wide-nocrop {{site.pimages}}{{page.slug}}/paddle.png --alt {{x and y access }} %}
<figcaption>A Paddle</figcaption>

We also need a way to move our paddle. For this, we'll use the same principle we did with our bouncing ball, adding speed to position. Again because we are dealing with a sprite that is larger than one character, we need to take the height into account. We don't want to let the paddle move off screen, so we need to check the Y value to make sure it's still part of the play field. 

```go
func (p *Paddle) MoveUp() {

	if p.Y > 0 {
		p.Y -= p.Yspeed
	}
}

func (p *Paddle) MoveDown(windowHeight int) {
	if p.Y < windowHeight-p.height {
		p.Y += p.Yspeed
	}
}
```

## Getting Control

Now we have a paddle, but we have no way to move it. In the first part we used `Screen.PollEvent` to listen for input. We can expand on what we already built to give us control over our paddle. To make things simple we'll assume you have a gamer friend that smells good enough to sit next to and share a keyboard with. We'll have the left paddle controlled by the "w" and "s" keys and for the right paddle we'll use the arrow keys.

```go
	width, height := s.Size() // we can update this line to grab that height value.
```

```go
switch event := game.Screen.PollEvent().(type) {
    case *tcell.EventResize:
        game.Screen.Sync()
    case *tcell.EventKey:
        if event.Key() == tcell.KeyEscape || event.Key() == tcell.KeyCtrlC {
            game.Screen.Fini()
            os.Exit(0)
        } else if event.Key() == tcell.KeyUp {
            game.Player2.MoveUp()
        } else if event.Key() == tcell.KeyDown {
            game.Player2.MoveDown(height)
        } else if event.Rune() == 'w' {
            game.Player1.MoveUp()
        } else if event.Rune() == 's' {
            game.Player1.MoveDown(height)
        }
```

Now we have movable paddles but if you try to  use them to hit the ball, the ball will pass right through. We need to write some code that will check to see if the coordinates of the paddle ever collide with the coordinate of the ball.

## Collision

TODO: Need to add video of a collision!

We'll need to write some code to tell us whether or not our ball has collided with one of our paddles. For now, we can probably get away with just writing a function connected to the Ball that checks if it has intersected with one of the paddles. Remember we need to keep in mind the width and height of the paddle.

```go
func (b *Ball) intersects(p Paddle) bool {
	return b.X >= p.X && b.X <= p.X+p.width && b.Y >= p.Y && b.Y <= p.Y+p.height
}
```

Then we can use this function to change the ball's direction just like we do when it gets to the edge of the screen, by reversing its speed. Since we are now doing this in a couple places, I wrote some additional functions to reverse the speed and updated the `checkEdges` function to use them. 

```go
func (b *Ball) reverseX() {
	b.Xspeed *= -1
}

func (b *Ball) reverseY() {
	b.Yspeed *= -1
}

func (b *Ball) CheckEdges(maxWidth int, maxHeight int) {
	if b.X <= 0 || b.X >= maxWidth {
		b.reverseX()
	}

	if b.Y <= 0 || b.Y >= maxHeight {
		b.reverseY()
	}
}
```

And then we can use them in our main event loop. 

```go
	if g.Ball.intersects(g.Player1) || g.Ball.intersects(g.Player2) {
		g.Ball.reverseX()
		g.Ball.reverseY()
	}
```
Now if we run the code we should be able to use both paddles to hit the ball.

## You Can't lose

In Pong, if the ball ends up behind your opponents paddle, you score a point. This usually means the ball disappears and then reappears in the middle. In the game of Pong I am modeling this off of, the ball usually reappears in the middle, moving toward whoever just lost the point. We can make this update pretty easily. First, let's get rid of the code that tells the ball to bounce whenver it reaches teh left or the right of the screen. That will leave our `checkEdges` method looking like this:

```go
func (b *Ball) CheckEdges(maxWidth int, maxHeight int) {

    // We delete the code that checks if
    // the ball is on the left or the right.

	if b.Y <= 0 || b.Y >= maxHeight {
		b.reverseY()
	}
}
```

Let's then write another function that let's us reset the balls position and direction.

```go
func (b *Ball) Reset(x int, y int, xSpeed int, ySpeed int) {
	b.X = x
	b.Y = y
	b.Xspeed = xSpeed
	b.Yspeed = ySpeed

}
```

Then, in our event loop, we can make the update as needed. 

```go
	if g.Ball.Body.X <= 0 {
        g.Ball.Reset(width/2, height/2, -1, 1)
    }

    if g.Ball.Body.X >= width {
        g.Ball.Reset(width/2, height/2, 1, 1)
    }
```

Run the code and let the ball get by one of the paddles. 

TODO: Need to show the ball reset here. Will want to comment out the score part.

## Declaring a Loser

I feel like the score should be something that's attached to the player. Let's create a Player struct. This way a player can have both a score and a paddle, and maybe in a later version, a user name or some other identifier.

```go
package main

type Player struct {
	Score  int
	Paddle Paddle
}
```

Then update our game struct:

```go
type Game struct {
	Screen  tcell.Screen
	Ball    Ball
	Player1 Player
	Player2 Player
}
```
And also in our `main.go`

```go
    player1 := Player{
		Score: 0,
		Paddle: Paddle{
			width:  1,
			height: 6,
			Y:      3,
			X:      5,
			Yspeed: 3,
		},
	}

	player2 := Player{
		Score: 0,
		Paddle: Paddle{
			width:  1,
			height: 6,
			Y:      3,
			X:      width - 5,
			Yspeed: 3,
		},
	}   
```

NOTE: Yes, you're going to have to go update every single place in the code where you had `g.Player1` to `g.Player1.Paddle` and you'll have to do it for both players. Will it be tedious and annoying: yes. Will it be everything programming every promised it would be: also yes. Is this me being to lazy to go back and rewrite this tutorial to account for this, no. I am whatever the oppisote of lazy is. Can't be bothered to look it up.

With our code updated to use the Player struct, we can not check the score in our event loop.

```go
    if g.Ball.X <= 0 {
        g.Player2.Score++
        g.Ball.Reset(width/2, height/2, -1, 1)
    }

    if g.Ball.X >= width {
        g.Player1.Score++
        g.Ball.Reset(width/2, height/2, 1, 1)
    }
```

Last thing to do would be to display the score. Make sure to remember to import `strconv`.

```go
	drawSprite(s, (width/2)-5, 1, 1, 1, defStyle, strconv.Itoa(g.Player1.Score))
	drawSprite(s, (width/2)+5, 1, 1, 1, defStyle, strconv.Itoa(g.Player2.Score))
```

## Game Over, Man

Last thing we need to do is allow the game to end. You can set the score to be whatever you want, but to make it easier to test and show in a quick video, I made it first score wins.

```go
func (g *Game) GameOver() bool {
	return g.Player1.Score == 1 || g.Player2.Score == 1
}

func (g *Game) DeclareWinner() string {
	if !g.GameOver() {
		return "Game Not Over. No Winner"
	}

	if g.Player1.Score > g.Player2.Score {
		return "Left Player"
	} else {
		return "Right Player"
	}
}
```

Then in our event loop inside of `Run`:

```go
	if g.GameOver() {
        drawSprite(s, (width/2)-4, 7, (width/2)+5, 7, defStyle, "Game Over")
        drawSprite(s, (width/2)-8, 11, (width/2)+10, 11, defStyle, g.DeclareWinner()+" Wins!")
        s.Show()
    }
```





### Writing Article Checklist

- [ ] Write Outline
- [ ] Write Draft
- [ ] Fix Grammarly Errors
- [ ] Read out loud
- [ ] Write 5 or more titles and pick the best on
- [ ] First two paragraphs: What's it about? Why listen to you?
- [ ] Create header image in Canva
- [ ] Optional: Find ways to break up content with quotes or images
- [ ] Verify look of article locally
- [ ] Run mark down linter (`lint`)
- [ ] Add keywords for internal links to front-matter
- [ ] Run `link-opp` and find 1-5 places to incorporate links to other articles
- [ ] Add Earthly `CTA` at bottom `{% include cta/cta1.html %}`
- [ ] Raise PR

## Outside Article Checklist

- [ ] Add in Author page
- [ ] Create header image in Canva
- [ ] Optional: Find ways to break up content with quotes or images
- [ ] Verify look of article locally
  - Would any images look better `wide` or without the `figcaption`?
- [ ] Run mark down linter (`lint`)
- [ ] Add keywords for internal links to front-matter
- [ ] Run `link-opp` and find 1-5 places to incorporate links
- [ ] Add Earthly `CTA` at bottom `{% include cta/cta1.html %}`
