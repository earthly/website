---
title: "JQ Select Explained: Selecting elements from JSON with Examples"
categories:
  - Tutorials
toc: true
author: Adam
internal-links:
 - just an example
---
## Writing Article Checklist

- [ ] Write Outline
- [ ] Write Draft
- [ ] Fix Grammarly Errors
- [ ] Read out loud
- [ ] Write 5 or more titles and pick the best on
- [ ] First two paragraphs: What's it about? Why listen to you?
- [ ] Create header image in Canva
- [ ] Optional: Find ways to break up content with quotes or images
- [ ] Verify look of article locally
- [ ] Run mark down linter (`earthly +blog-lint-apply`)
- [ ] Add keywords for internal links to front-matter
- [ ] Run `earthly --build-arg NAME=2020-09-10-better-builds.md +link-opportunity` and find 1-5 places to incorporate links to other articles
- [ ] Raise PR


- Keyword: jq select
- Long tail keywords:
    - jq select multiple fields
    - jq select examples
    - jq select key value
    - jq filter by value
    - jq count
    - jq sort
    - jq json to csv
    - jq map
    - jq array
    - harder ones
        - what is jq
        - jq filter

## Background: Fingers, Head, and Google

Some actions are just in my fingers. I don't have to remember how to use them. My fingers just know how. My alias for `git commit` is my fingers. I commit my work almost automatically when I reach a stopping point. Other actions, I know how they work, but I have to think about it every time. They are in my head, not my fingers.[^1]

However, some things never stick in my head nor in my fingers and I have to go to google every time. **`jq` is one of these.** 


It's time to fix that. Let's go over `jq` in enough depth that it should stick in your head (and maybe your fingers).

## What is JQ

`jq` is a lightweight, command-line JSON processor. It a single portable executable that is less than 1 MB is size but it is by no means a simple tool. To use `jq`, you construct one or more filters and it applies those filters to a JSON document. 

The simplest filter is the identity filter which returns all its input (`.`):

``` bash
$ echo '{"key1":{"key2":"value1"}}' | jq '.'
{
  "key1": {
    "key2": "value1"
  }
}
```

This filter is handy for just pretty printing a JSON document. 

<div class="notice--info">
**Side Note: Pretty Printing**

By default jq pretty prints all its output. Whenever jq returns some data, its implied, though not specifically stated, that the data has be pretty printed.
</div>

## Using JQ to Select Elements
Let's start learning how to select elements using the GitHub api for `jq`.
``` bash
$ curl https://api.github.com/repos/stedolan/jq
{
  "id": 5101141,
  "node_id": "MDEwOlJlcG9zaXRvcnk1MTAxMTQx",
  "name": "jq",
  "full_name": "stedolan/jq",
  "private": false,
  "owner": {
    "login": "stedolan",
    "id": 79765
  },
  "html_url": "https://github.com/stedolan/jq",
  "description": "Command-line JSON processor",
  "stargazers_count": 19967,
  "watchers_count": 19967,
  "language": "C",
  "license": {
    "key": "other",
    "name": "Other",
    "spdx_id": "NOASSERTION",
    "url": null,
    "node_id": "MDc6TGljZW5zZTA="
  },
}
```

<div class="notice--info">
**Side Note: Omitting Details**

The JSON documents returned by the GitHub API are in many cases quite large. Non relevant details will be omitted in this tutorial.
</div>

`jq` lets us treat the JSON document as an object, and select elements inside of it.

Here is how I filter JSON document to select value of the `name` key:

``` bash
curl https://api.github.com/repos/stedolan/jq | jq ' .name' 
"jq"
```
<figcaption></figcaption>

Similarly for selecting the value of the `owner` key:

``` bash
$ curl https://api.github.com/repos/stedolan/jq | jq ' .owner' 
{
    "login": "stedolan",
    "id": 79765
}
```

You can drill in as far as you want like this:

``` bash
$ curl https://api.github.com/repos/stedolan/jq | jq ' .owner.login' 
"stedolan"
```

<div class="notice--big--primary">

**What I Learned: Object Identifier-Index**

`jq` lets you select elements in a JSON document like its a JavaScript object. Just start with `.` ( for the whole document) and drill down to the value you want.
It ends up looking something like this:

``` bash
jq '.key.subkey.subsubkey'
```
</div>


## Using JQ to Select Arrays
If we use the GitHub Issues API for `jq` we get back an array of issues:
``` bash
curl https://api.github.com/repos/stedolan/jq/issues?per_page=5    
[
  {
    "id": 966024429,
    "number": 2341,
    "title": "Question about license.",
    "body": "I would like to create a [winget](https://github.com/microsoft/winget-cli) package for jq. üôèüèª"
  },
  {
  
    "id": 962477084,
    "number": 2340,
    "title": "visibility of wiki pages",
    "body": "The visibility of wiki pages to search engines is generally limited; for example, the search result for \"jq Cookbook\" looks like this:"
  },
  {
   
    "id": 955350543,
    "number": 2337,
    "title": "Release 1.6 does not have pre-autoreconf'ed configure script",
    "body": "If you have a usage question, please ask us on either Stack Overflow (https://stackoverflow.com/questions/tagged/jq) or in the #jq channel (http://irc.lc/freenode/%23jq/) on Freenode (https://webchat.freenode.net/)."
  },
  {
    "id": 954792209,
    "number": 2336,
    "title": "Fix typo",
    "body": ""
  },
  {
    "id": 940627936,
    "number": 2334,
    "title": "Compile error messages don't provide column only line number",
    "body": "Compile errors in filter expressions don't include the column number where the parser approximately or exactly locates the error. Most filter expressions are one-liners (are multiple lines even supported?), so the information that the error is on line 1 is not helpful."
  }
]
```
To get a specific element in the array give an index
``` bash
curl https://api.github.com/repos/stedolan/jq/issues?per_page=5 | jq '.[4]' 
 {
    "id": 940627936,
    "number": 2334,
    "title": "Compile error messages don't provide column only line number",
    "body": "Compile errors in filter expressions don't include the column number where the parser approximately or exactly locates the error. Most filter expressions are one-liners (are multiple lines even supported?), so the information that the error is on line 1 is not helpful."
  }
```
<div class="notice--info">
**Side Note: Array Indexing in `jq`**

Array indexing has some nice convenience functions. 

You can select ranges:
``` bash
$ echo "[1,2,3,4,5]" | jq '.[2:4]'
[3,4]
```

You can select one sided ranges:

``` bash
$ echo "[1,2,3,4,5]" | jq '.[2:]'
[3,4,5]
```

You can use negatives to select from the end:

``` bash
$ echo "[1,2,3,4,5]" | jq '.[-2:]'
[4,5]
```
</div>

You can use the array indexing with the object indexing:
``` bash
$ curl https://api.github.com/repos/stedolan/jq/issues?per_page=5 | jq '.[4].title' 
"Compile error messages don't provide column only line number"
```
And you can use `[]` to get all the elements in array. This is useful when you want to apply furthering filtering to elements of the array. Here is how we would get the titles of  the jq issues returned by our api request :
``` bash
$ curl https://api.github.com/repos/stedolan/jq/issues?per_page=5 | jq '.[].title' 
"Question about license."
"visibility of wiki pages"
"Release 1.6 does not have pre-autoreconf'ed configure script"
"Fix typo"
"Compile error messages don't provide column only line number"
```

<div class="notice--big--primary">
**What I Learned: Array-Index**

`jq` lets you select the whole array `[]`, specific elements in an array `[3]`, or ranges of elements `[2:5]` and combine these with object index where needed. 

It ends up looking something like this: 
``` bash
jq '.key[].subkey[2]
```
</div>

<div class="notice--info">
**Side Note: Removing Quotes From JQ Output**

If you need to have raw strings, the `-r` option in `jq` gives you that.

``` bash
$ echo '["1","2","3"]' | jq -r '.[]'
1
2
3
```

The `-j` option (for join) can also be use to combine together output.

```bash
$ echo '["1","2","3"]' | jq -j '.[]'
123
```
</div>

## Putting Elements in an Array using `jq`

Not everything emitted by `jq` is valid JSON. When we extracted titles from the `jq` issues page able out result was not not a valid JSON array. In order to put a collection of results produced by a filter into a JSON array we just wrap it in `[ ... ]` where `...` is our filter that emits a collection of elements. So our title filter (`.[].title`) becomes `[ .[].title ]` like this:

``` bash
$ curl https://api.github.com/repos/stedolan/jq/issues?per_page=5 | \
  jq '[ .[].title ] ' 
[
  "Question about license.",
  "visibility of wiki pages",
  "Release 1.6 does not have pre-autoreconf'ed configure script",
  "Fix typo",
  "Compile error messages don't provide column only line number"
]
```
## Using `jq` to Select Multiple Fields

The GitHub issues API has a lot of details we don't care about. Let's select multiple fields from the document and leave the rest behind. The easiest way to do this is using `,` to specify multiple select filters:
``` bash
$ curl https://api.github.com/repos/stedolan/jq/issues?per_page=2 | \ 
  jq ' .[].title, .[].number'
"Question about license."
"visibility of wiki pages"
2341
2340
```
This returns the result of one selection after the other. We can change the ordering to be per array element by factoring out the array selector. This causes our object selectors to be run per array element and gives us the order we expect:
``` bash
$ curl https://api.github.com/repos/stedolan/jq/issues?per_page=2 | \
  jq '.[] |  .title, .number'
"Question about license."
2341
"visibility of wiki pages"
2340
```
If you wrap the query in the array constructor you get this:
``` bash
$ curl https://api.github.com/repos/stedolan/jq/issues?per_page=2 | \
  jq '[ .[] |  .title, .number ]'
[
  "Question about license.",
  2341,
  "visibility of wiki pages",
  2340
]
```

But this still isn't the JSON document we need. In order to get these values into a proper JSON document the object constructor `{ ... }` is needed. The object construction syntax lets you build up a JSON object using jq filters for both keys and values.

``` bash
$ curl https://api.github.com/repos/stedolan/jq/issues?per_page=2 | \
  jq '[ .[] | { title: .title, number: .number} ]'
[
  {
    "title": "Question about license.",
    "number": 2341
  },
  {
    "title": "visibility of wiki pages",
    "number": 2340
  }
]

```


<div class="notice--big--primary">
**What I Learned: Array and Object Constructors**

To put the elements you have selected back into a JSON document form you can wrap them in the array constructor `[ .. ]` and the object constructor `{ ... }`.

`jq` lets you select the whole array `[]`, specific elements in an array `[3]`, or ranges of elements `[2:5]` and combine these with object index where needed. 

If you were emitting an array of objects then it ends up looking something like this: 
``` bash
jq '[ { key1: <<jq filter>>, key2: <<jq filter>> } ]'

```
Both keys and value can be `jq` filters.
</div>

## Sorting and Counting With JQ

Next problem I have is I want to summarize some this JSON data. Each issue returned by GitHub has a collection of labels:

``` bash
$ curl https://api.github.com/repos/stedolan/jq/issues/2289    
  jq ' { title: .title, number: .number, labels: .labels} '
  {
    "title": "Bump jinja2 from 2.10 to 2.11.3 in /docs",
    "number": 2289,
    "labels": [
      "feature request",
      "dependencies"
    ]
  }
```
If I want those labels in alphabetical order I can use the built in `sort` function. It works like this:
``` bash
$  echo '["3","2","1"]' | jq 'sort'
["1", "2", "3"]
```
Combining this built in with our existing filter selectors takes a little bit of explaining though.

`jq` is a filter: You pipe a JSON document to it and it filters and outputs it. But the `jq` language is also made up of filters itself and you can combine these filters together. 

Most of the things we've seen so far are filters:

 *  `.title` is a filter that takes in a JSON document and filters it to only return the values of key 'title'.  
 * `[]` is a filter that given an array, returns the elements of the array
 * `[2:4]` is a filter that give an array returns elements 2 through 4.

 We can join these filters together using with jq's built functions using a pipe `|` just like in a unix shell.
 
 *  `.title | length` will return the length of the title
 * `[] | sort` will return the array elements in sorted order
 * `.number | tostring` will return our issue number as a string

All this means that sorting our labels is simple. We just change `.labels` to `.labels | sort`:

``` bash
$ curl https://api.github.com/repos/stedolan/jq/issues/2289 | \
  jq ' { title: .title, number: .number, labels: .labels | sort } '    
  {
    "title": "Bump jinja2 from 2.10 to 2.11.3 in /docs",
    "number": 2289,
    "labels": [
      "dependencies",
      "feature request"
    ]
  }
```

And if we want just a label count that is easy as well:

``` bash
$ curl https://api.github.com/repos/stedolan/jq/issues/2289 | \
  jq ' { title: .title, number: .number, labels: .labels | length } '    
  {
    "title": "Bump jinja2 from 2.10 to 2.11.3 in /docs",
    "number": 2289,
    "labels": 2
  }
```

<div class="notice--big--primary">
**What I Learned: Pipes and builtins**

`jq` has a number of built in functions and you can combine with each other and with your queries using the pipe operator (`|`).

If you were emitting an array of objects then it ends up looking something like this: 
``` bash
jq ' .key1.subkey2[] | sort ' # sorting
jq ' .key2.subkey | length' # length of string or array
jq ' .key3 | floor | tostring | length' # and so on

```
</div>

## Maps and Selects Using JQ
Now lets say you want to select all the issues that are labeled. It's possible to query for a specific label with the issues api, but just getting all issues that have any labels at all is a bit more tricky. Especially if the set of possible labels is large. Never fear though, we can easily do this query on the command line by filtering our results with `jq`.

Our query so far looks like this:
```
  jq '[ .[] | { title: .title, number: .number, labels: .labels | length } ]'
```
The first thing we can do is simplify using `map`.  

```
  jq 'map({ title: .title, number: .number, labels: .labels | length }) 
```
You can think of `map(...)` as a short hand for `[ .[] | ...  ] - that is unwrap this array, apply the filter and then rewrap the results back into an array. 

We can combine that with a select statement like this:
``` bash
map(select(.labels > 0))
```
Select is a built-in function that a boolean expression and only returns elements that match. It's similar to the WHERE clause in a SQL statement or array filter in JavaScript.

Putting this all together looks like this:
``` bash
curl https://api.github.com/repos/stedolan/jq/issues?per_page=100 | \
   jq 'map({ title: .title, number: .number, labels: .labels | length }) | 
   map(select(.labels > 0))'
[
  {
    "title": "Bump lxml from 4.3.1 to 4.6.3 in /docs",
    "number": 2295,
    "labels": 1
  },
  {
    "title": "Bump pyyaml from 3.13 to 5.4 in /docs",
    "number": 2291,
    "labels": 1
  },
  {
    "title": "Bump jinja2 from 2.10 to 2.11.3 in /docs",
    "number": 2289,
    "labels": 1
  },
  {
    "title": "Debugging help through showing pipeline intermediates. ",
    "number": 2206,
    "labels": 1
  }
]
```

<div class="notice--big--primary">

**What I Learned: JQ CheatSheet**

`jq` lets you select elements by starting with a `.` and accessing keys and arrays like its a JavaScript Object (which is it is). This feature uses the Object and Array index jq creates of a JSON document and look like this:

* `jq '.key[0].subkey[2:3].subsubkey'`

`jq` contains object constructors `{ ... }` and array constructors `[ ... ]` for wrapping things back up into a JSON document that have been pulled out using above indexes:

* `jq '[ { key1: .key1, key2: .key2 }  ]'`

`jq` contains built in functions (`length`,`sort`,`select`,`map`) and pipes (`|`) and you can compose these together just like you can combine pipes and filters in a command line shell:

``` bash
  jq 'map({ order-of-magitude: .items | length | tostring | length }) 
```
</div>

## Conclusion

This is only the basics of `jq`. The `jq` query language is a full programming language and you can do lots of exciting things with it. Like define you own functions and even [finding primes](https://rosettacode.org/wiki/Sieve_of_Eratosthenes#jq):

``` haskell
# Denoting the input by $n, which is assumed to be a positive integer,
# eratosthenes/0 produces an array of primes less than or equal to $n:
def eratosthenes:
  (. + 1) as $n
  | (($n|sqrt) / 2) as $s
  | [null, null, range(2; $n)]
  | reduce (2, 1 + (2 * range(1; $s))) as $i (.; erase($i))
  | map(select(.));
```

 However, the simple stuff like selecting elements and filtering values by key or value are often all you need. 

I hope this helps make `jq` more approachable and that you no longer have to go to google for every `jq` query. 


[^1]: A note for the pedants: automated behaviour is stored in your Basal ganglia. It feels like it's in my fingers but really these actions just fire at a level below my awareness. 