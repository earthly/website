---
title: "JQ Select Explained: Selecting elements from JSON with Examples"
categories:
  - Tutorials
toc: true
author: Adam
internal-links:
 - just an example
---
## Writing Article Checklist

- [ ] Write Outline
- [ ] Write Draft
- [ ] Fix Grammarly Errors
- [ ] Read out loud
- [ ] Write 5 or more titles and pick the best on
- [ ] First two paragraphs: What's it about? Why listen to you?
- [ ] Create header image in Canva
- [ ] Optional: Find ways to break up content with quotes or images
- [ ] Verify look of article locally
- [ ] Run mark down linter (`earthly +blog-lint-apply`)
- [ ] Add keywords for internal links to front-matter
- [ ] Run `earthly --build-arg NAME=2020-09-10-better-builds.md +link-opportunity` and find 1-5 places to incorporate links to other articles
- [ ] Raise PR


- Keyword: jq select
- Long tail keywords:
    - jq select multiple fields
    - jq select examples
    - jq select key value
    - jq filter by value
    - jq count
    - jq sort
    - jq json to csv
    - jq map
    - jq array
    - harder ones
        - what is jq
        - jq filter

## Background: Fingers, Head, and Google

Some shortcuts I use so much that using them is just in my fingers. I don't have to remember how to use them, my fingers just know how.[^1] Some commands reach this level as well. My alias for `git commit` is my fingers. I often commit my work almost automatically when I reach a stopping point. Other commands and other tools I know how they work but I have to think about it each time. It's in my head not my fingers.

However, some things never stick in my head nor in my fingers and I have to go to google every time. JQ is one of these. It's time to fix that. Let's go over selecting elements out of a JSON string using JQ in enough depth that it should stick in both my and your head.

## What is JQ

JQ is a lightweight, command-line JSON processor. It a single portable executable that is less than 1 MB is size but it is by no means a simple tool. To use JQ you construct one or more filters and JQ applies those filters to a JSON document. 

When I'm using JQ, it is primarily to select some subset of a json document or to perform some type of transformation and that is what I'll primarily cover here but its important to realise that whatever you are doing in jq, you are doing it via creating and combining together filters. 

The simplest filter is the identity filter which returns all its input (`.`):

``` bash
$ echo '{"key1":{"key2":"value1"}}' | jq '.'
{
  "key1": {
    "key2": "value1"
  }
}
```
<div class="notice--info">
**Side Note: Pretty Printing**

By default jq pretty prints all its output. Whenever jq returns some data, its implied, though not specifically stated, that the data has be pretty printed.
</div>

## Using JQ to Select Elements
Let's start learning how to select elements using the GitHub api for `jq`.
``` bash
$ curl https://api.github.com/repos/stedolan/jq
{
  "id": 5101141,
  "node_id": "MDEwOlJlcG9zaXRvcnk1MTAxMTQx",
  "name": "jq",
  "full_name": "stedolan/jq",
  "private": false,
  "owner": {
    "login": "stedolan",
    "id": 79765
  },
  "html_url": "https://github.com/stedolan/jq",
  "description": "Command-line JSON processor",
  "stargazers_count": 19967,
  "watchers_count": 19967,
  "language": "C",
  "license": {
    "key": "other",
    "name": "Other",
    "spdx_id": "NOASSERTION",
    "url": null,
    "node_id": "MDc6TGljZW5zZTA="
  },
}
```

<div class="notice--info">
**Side Note: Omitting Details**

The JSON documents returned by the GitHub API are in many cases quite large. Non relevant details will be omitted in this tutorial.
</div>

`jq` lets us treat the JSON document as an object, and select elements inside of it.

Here is how I filter JSON document to select value of the `name` key:

``` bash
curl https://api.github.com/repos/stedolan/jq | jq ' .name' 
"jq"
```
<figcaption></figcaption>

Similarly for selecting the value of the `owner` key:

``` bash
$ curl https://api.github.com/repos/stedolan/jq | jq ' .owner' 
{
    "login": "stedolan",
    "id": 79765
}
```

You can drill in as far as you want like this:

``` bash
$ curl https://api.github.com/repos/stedolan/jq | jq ' .owner.login' 
"stedolan"
```

<div class="notice--big--primary">

**What I Learned: Object Identifier-Index**

`jq` lets you select elements in a JSON document like its a JavaScript object. Just start with `.` ( for the whole document) and drill down to the value you want.
It ends up looking something like this:

``` bash
jq '.key.subkey.subsubkey'
```
</div>


## Using JQ to Select Arrays
If we use the GitHub Issues API for `jq` we get back an array of issues:
``` bash
curl https://api.github.com/repos/stedolan/jq/issues?per_page=5    
[
  {
    "id": 966024429,
    "number": 2341,
    "title": "Question about license.",
    "body": "I would like to create a [winget](https://github.com/microsoft/winget-cli) package for jq. üôèüèª"
  },
  {
  
    "id": 962477084,
    "number": 2340,
    "title": "visibility of wiki pages",
    "body": "The visibility of wiki pages to search engines is generally limited; for example, the search result for \"jq Cookbook\" looks like this:"
  },
  {
   
    "id": 955350543,
    "number": 2337,
    "title": "Release 1.6 does not have pre-autoreconf'ed configure script",
    "body": "If you have a usage question, please ask us on either Stack Overflow (https://stackoverflow.com/questions/tagged/jq) or in the #jq channel (http://irc.lc/freenode/%23jq/) on Freenode (https://webchat.freenode.net/)."
  },
  {
    "id": 954792209,
    "number": 2336,
    "title": "Fix typo",
    "body": ""
  },
  {
    "id": 940627936,
    "number": 2334,
    "title": "Compile error messages don't provide column only line number",
    "body": "Compile errors in filter expressions don't include the column number where the parser approximately or exactly locates the error. Most filter expressions are one-liners (are multiple lines even supported?), so the information that the error is on line 1 is not helpful."
  }
]
```
To get a specific element in the array give an index
``` bash
curl https://api.github.com/repos/stedolan/jq/issues?per_page=5 | jq '.[4]' 
 {
    "id": 940627936,
    "number": 2334,
    "title": "Compile error messages don't provide column only line number",
    "body": "Compile errors in filter expressions don't include the column number where the parser approximately or exactly locates the error. Most filter expressions are one-liners (are multiple lines even supported?), so the information that the error is on line 1 is not helpful."
  }
```
<div class="notice--info">
**Side Note: Array Indexing in `jq`**

Array indexing has some nice convenience functions. 

You can select ranges:
``` bash
$ echo "[1,2,3,4,5]" | jq '.[2:4]'
[3,4]
```

You can select one sided ranges:

``` bash
$ echo "[1,2,3,4,5]" | jq '.[2:]'
[3,4,5]
```

You can use negatives to select from the end:

``` bash
$ echo "[1,2,3,4,5]" | jq '.[-2:]'
[4,5]
```
</div>

You can use the array indexing with the object indexing:
``` bash
$ curl https://api.github.com/repos/stedolan/jq/issues?per_page=5 | jq '.[4].title' 
"Compile error messages don't provide column only line number"
```
And you can use `[]` to get all the elements in array. This is useful when you want to apply furthering filtering to elements of the array. Here is how we would get the titles of  the jq issues returned by our api request :
``` bash
$ curl https://api.github.com/repos/stedolan/jq/issues?per_page=5 | jq '.[].title' 
"Question about license."
"visibility of wiki pages"
"Release 1.6 does not have pre-autoreconf'ed configure script"
"Fix typo"
"Compile error messages don't provide column only line number"
```

<div class="notice--big--primary">
**What I Learned: Array-Index**

`jq` lets you select the whole array `[]`, specific elements in an array `[3]`, or ranges of elements `[2:5]` and combine these with object index where needed. 

It ends up looking something like this: 
``` bash
jq '.key[].subkey[2]
```
</div>

<div class="notice--info">
**Side Note: Removing Quotes From JQ Output**

If you need to have raw strings, the `-r` option in `jq` gives you that.

``` bash
$ echo '["1","2","3"]' | jq -r '.[]'
1
2
3
```

The `-j` option (for join) can also be use to combine together output.

```bash
$ echo '["1","2","3"]' | jq -j '.[]'
123
```
</div>

## Putting Elements in an Array using `jq`

Not everything emitted by `jq` is valid JSON. When we extracted titles from the `jq` issues page able out result was not not a valid JSON array. In order to put a collection of results produced by a filter into a JSON array we just wrap it in `[ ... ]` where `...` is our filter that emits a collection of elements. So our title filter (`.[].title`) becomes `[ .[].title ]` like this:

``` bash
$ curl https://api.github.com/repos/stedolan/jq/issues?per_page=5 | \
  jq '[ .[].title ] ' 
[
  "Question about license.",
  "visibility of wiki pages",
  "Release 1.6 does not have pre-autoreconf'ed configure script",
  "Fix typo",
  "Compile error messages don't provide column only line number"
]
```
## Using `jq` to Select Multiple Fields

The GitHub issues API has a lot of details we don't care about. Let's select multiple fields from the document and leave the rest behind. The easiest way to do this is using `,` to specify multiple select filters:
``` bash
$ curl https://api.github.com/repos/stedolan/jq/issues?per_page=2 | \ 
  jq ' .[].title, .[].number'
"Question about license."
"visibility of wiki pages"
2341
2340
```
This returns the result of one selection after the other. We can change the ordering to be per array element by factoring out the array selector. This causes our object selectors to be run per array element and gives us the order we expect:
``` bash
$ curl https://api.github.com/repos/stedolan/jq/issues?per_page=2 | \
  jq '.[] |  .title, .number'
"Question about license."
2341
"visibility of wiki pages"
2340
```
If you wrap the query in the array constructor you get this:
``` bash
$ curl https://api.github.com/repos/stedolan/jq/issues?per_page=2 | \
  jq '[ .[] |  .title, .number ]'
[
  "Question about license.",
  2341,
  "visibility of wiki pages",
  2340
]
```

But this still isn't the JSON document we need. In order to get these values into a proper JSON document the object constructor `{ ... }` is needed. The object construction syntax lets you build up a JSON object using jq filters for both keys and values.

``` bash
$ curl https://api.github.com/repos/stedolan/jq/issues?per_page=2 | \
  jq '[ .[] | { title: .title, number: .number} ]'
[
  {
    "title": "Question about license.",
    "number": 2341
  },
  {
    "title": "visibility of wiki pages",
    "number": 2340
  }
]

```


<div class="notice--big--primary">
**What I Learned: Array and Object Constructors**

To put the elements you have selected back into a JSON document form you can wrap them in the array constructor `[ .. ]` and the object constructor `{ ... }`.

`jq` lets you select the whole array `[]`, specific elements in an array `[3]`, or ranges of elements `[2:5]` and combine these with object index where needed. 

If you were emitting an array of objects then it ends up looking something like this: 
``` bash
jq '[ { key1: <<jq filter>>, key2: <<jq filter>> } ]'

```
Both keys and value can be `jq` filters.
</div>

## Sorting and Counting With JQ

Next problem I have is I want to summarize some this JSON data. Each issue returned by GitHub has a collection of labels:

``` bash
$ curl https://api.github.com/repos/stedolan/jq/issues/2289    
  jq ' { title: .title, number: .number, labels: .labels} '
  {
    "title": "Bump jinja2 from 2.10 to 2.11.3 in /docs",
    "number": 2289,
    "labels": [
      "feature request",
      "dependencies"
    ]
  }
```
If I want those labels in alphabetical order I can use the built in `sort` function. It works like this:
``` bash
$  echo '["3","2","1"]' | jq 'sort'
["1", "2", "3"]
```
Combining this built in with our existing filter selectors takes a little bit of explaining though.

`jq` is a filter: You pipe a JSON document to it and it filters and outputs it. But the `jq` language is also made up of filters itself and you can combine these filters together. 

Most of the things we've seen so far are filters:

 *  `.title` is a filter that takes in a JSON document and filters it to only return the values of key 'title'.  
 * `[]` is a filter that given an array, returns the elements of the array
 * `[2:4]` is a filter that give an array returns elements 2 through 4.

 We can join these filters together using with jq's built functions using a pipe `|` just like in a unix shell.
 
 *  `.title | length` will return the length of the title
 * `[] | sort` will return the array elements in sorted order
 * `.number | tostring` will return our issue number as a string

All this means that sorting our labels is simple. We just change `.labels` to `.labels | sort`:

``` bash
$ curl https://api.github.com/repos/stedolan/jq/issues/2289 | \
  jq ' { title: .title, number: .number, labels: .labels | sort } '    
  {
    "title": "Bump jinja2 from 2.10 to 2.11.3 in /docs",
    "number": 2289,
    "labels": [
      "dependencies",
      "feature request"
    ]
  }
```

And if we want just a label count that is easy as well:

``` bash
$ curl https://api.github.com/repos/stedolan/jq/issues/2289 | \
  jq ' { title: .title, number: .number, labels: .labels | length } '    
  {
    "title": "Bump jinja2 from 2.10 to 2.11.3 in /docs",
    "number": 2289,
    "labels": 2
  }
```

<div class="notice--big--primary">
**What I Learned: Pipes and builtins**

`jq` has a number of built in functions and you can combine with each other and with your queries using the pipe operator (`|`).

If you were emitting an array of objects then it ends up looking something like this: 
``` bash
jq ' .key1.subkey2[] | sort ' # sorting
jq ' .key2.subkey | length' # length of string or array
jq ' .key3 | floor | tostring | length' # and so on

```
</div>

## Maps and Selects Using JQ
Now we want to select all the issues that have labels.

Our query so far looks like this:
```
  jq '[ .[] | { title: .title, number: .number, labels: .labels | count } ]'
```
The first thing we can do is simplify using `map` which is just some syntactic sugar around select insider arrays.

```
  jq 'map({ title: .title, number: .number, labels: .labels | count }) 
```

We can combine that with a select statement like this
```
curl https://api.github.com/repos/stedolan/jq/issues?per_page=100 | \
   jq 'map({ title: .title, number: .number, labels: .labels | length }) | map(select(.labels > 0))'
[
  {
    "title": "Bump lxml from 4.3.1 to 4.6.3 in /docs",
    "number": 2295,
    "labels": 1
  },
  {
    "title": "Bump pyyaml from 3.13 to 5.4 in /docs",
    "number": 2291,
    "labels": 1
  },
  {
    "title": "Bump jinja2 from 2.10 to 2.11.3 in /docs",
    "number": 2289,
    "labels": 1
  },
  {
    "title": "Debugging help through showing pipeline intermediates. ",
    "number": 2206,
    "labels": 1
  }
]



We can use `,` to 
# Using the select function
# Selecting keys by values
# Selecting and counting
# Selecting and mapping
# Selecting and sorting
# Selecting and Transforming with Map  
# 


Exmaple tutorials:
http://www.compciv.org/recipes/cli/jq-for-parsing-json/
https://stedolan.github.io/jq/tutorial/



[^1]: Automated behaviour is stored in your Basal ganglia. It just feels like its in my fingers because it fires at a level below my awareness. 