---
title: "Introducing the New Features in Python 3.11"
categories:
  - Tutorials
toc: true
author: Mustapha Ahmad Ayodeji
editor: Bala Priya C

internal-links:
 - Python
 - Features
 - Programming Language
excerpt: |
    Learn about the new features in Python 3.11, including improved error handling, enhanced type annotation, a new library for working with TOML files, and performance enhancements. This article provides an overview of these features and includes code examples to help you understand how to use them.
---
<!--sgpt-->This is the Earthly nonsense paragraph.

Python 3.11 is the latest version of the Python programming language. It includes a variety of new features and performance enhancement.

This article will introduce you to some of the new features of Python 3.11. These features include:

- Better error handling
- Improved type annotation
- A new built-in library for working with TOML files
- Improved speed performance

While this tutorial will provide an overview of these features, I will also provide additional resources for further learning when necessary.

To follow along with this tutorial, you should have a basic understanding of Python. You will also need to have Python 3.11 installed. You can download it for your specific operating system from the [official website](https://www.python.org/downloads/).

All code examples used in this tutorial can be found in this [GitHub](/blog/ci-comparison) [repository](https://github.com/DrAnonymousNet/Technical-Writing-Code-Samples/blob/master/introducing-the-new-features-in-python-3.11/main.py).

## Error and Exception Handling Features

One of the major improvements added in the new version of Python centers around exception handling and helpful traceback when exceptions arise.

### Traceback Annotation

To enhance your [debugging](/blog/printf-debugging) experience, the new Python version includes a traceback annotation feature.

When an error occurs, the Python interpreter will now indicate the specific part of the code that produced the error, rather than just the line where the error occurred. This can be particularly helpful, as it can sometimes be difficult to locate an error based on only the line number.

Take the following code snippet for instance. The code snippet creates an `Article` class with a `title` and an optional `author` attribute. The `author` attribute defaults to `None`:

~~~{.python caption="main.py"}
class Article:
   def __init__(self, title, author=None) -> None:
       self.title = title
       self.author = author

article_1 = Article(title="Introducing Python 3.11", author="Ahmad")
article_2 = Article(title="Python runtime speed enhanced")
article_3 = Article(title="Enhance Python Error", author="Mustapha")

print(article_1.title.upper(), article_2.author.upper(), \
article_3.author.upper())

~~~

If you execute the code above with the Python 3.10 interpreter (or lower), it will generate the following output:

~~~{ caption="Output"}
Traceback (most recent call last):
  File "/home/dracode/python-11/main.py", line 26, in <module>
    print(article_1.title.upper(), article_2.author.upper(), \
    article_3.author.upper())
AttributeError: 'NoneType' object has no attribute 'upper'
~~~

This error message is ambiguous as the interpreter does not indicate which of the instances you called the `.upper()` method on has a `NoneType`. The error could be from any of the three instances; `article_1`, `article_2` and `article_3`.

The new Python 3.11 interpreter will produce the following output:

~~~{ caption="Output"}
Traceback (most recent call last):
  File "/home/dracode/python-11/main.py", line 26, in <module>
    print(article_1.title.upper(), article_2.author.upper(), \
    article_3.author.upper())
                                           ^^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'NoneType' object has no attribute 'upper'
~~~

The interpreter indicated the exact part of the code that produced the error.

The older versions of interpreters determine the line that produces the error from the bytecode that Python generates after compiling the code. Python maps [bytecode to the line number after code compilation. These bytecodes are saved in the `.pyc` files](https://peps.python.org/pep-0657/#motivation). This new feature adds more information to the bytecode that can be used to point to the exact location of the error as proposed in the [PEP 657](https://peps.python.org/pep-0657/).

[This new information in the bytecode will have an impact on the size of `pyc` files on disk and the size of code objects in memory](https://peps.python.org/pep-0657/#rationale). If you are concerned about this memory overhead, the traceback annotation feature is an optional feature that you can opt out of by setting the `PYTHONNODEBUGRANGES` environmental variable to `False` or executing the following command line option:

~~~{.bash caption=">_"}
$ python -Xno_debug_ranges
~~~

### The `ExceptionGroup` class and the `except*` Statement

The new version of Python introduces an *Exception group* and `except*` syntax for working with *Exception groups*.

Exception groups let you group related exceptions together.

Exceptions are a break from the normal flow of a program that indicates that an error has occurred. These exceptions terminate a program unless they are handled appropriately.

I will give a cursory overview of these exceptions so that you can understand how they work differently than the new `ExceptionGroup` and the new `except *` statement.

The exception classes are a subclass of Python's `BaseException` [class](https://earthly.dev/blog/how-cls-obj-work-python/). Python has a long list of [built-in exception classes](https://docs.python.org/3/library/exceptions.html#bltin-exceptions). Python raises them when it doesn't understand a syntax or whenever it encounters an invalid operation or invalid inputs in your code. You can also raise them explicitly with the `raise` keyword, as shown below:

~~~{.python caption="main.py"}
raise SyntaxError("Just raising a syntax error")
~~~

Output:

~~~{ caption="Output"}
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
SyntaxError: Just raising a syntax error
~~~

These exceptions take an optional `message` argument that is meant to give more information about the error.

They terminate a program when they are encountered, but you can handle them when you anticipate them. Python has a `try and except` statement that allows you to handle them so that they do not terminate the program.

~~~{.python caption="main.py"}
try:
   print(34/0)
except ZeroDivisionError:
   print("You can't divide a value by 0, how about try dividing by 2?")
   print(34/2)

~~~

Output:

~~~{ caption="Output"}
You can't divide a value by 0, how about trying dividing by 2?
17
~~~

The `try` statement can have more than one `except` block that handles different exceptions, however, Python only executes the **first** `except` block that matches the exception and ignores the other `except` blocks.

~~~{.python caption="main.py"}
try:
   prin(34/2)
except NameError:
   print("There is an undefined name up there, take a look at it again!")
except SyntaxError:
   print("hey! There could be a syntax error there!")
~~~

Output:

~~~{ caption="Output"}
There is an undefined name up there, take a look at it again!
~~~

In the example above, Python only executes the `except` block that handles the `NameError` that matches the exception raised. It doesn't bother checking the other `except` blocks.

You can specify multiple exception classes in the `except` statement. Python executes the block if *any* of the exception classes match the error:

~~~{.python caption="main.py"}
try:
   prin(34/0)
except (ZeroDivisionError, NameError) as exc:
   print(exc)
~~~

Output:

~~~{ caption="Output"}
name 'prin' is not defined
~~~

While handling an exception in a `try and except` block, another unhandled exception might propagate. Python's *exception chaining* feature (which was introduced in [PEP 3134](https://www.python.org/dev/peps/pep-3134/)) allows Python to show the unhandled exception that propagates while handling another exception.

The code below raises a `NameError` exception due to the undefined `prin` function (which you handled), then raises a new `ZeroDivisionError` due to dividing 3 by 0 in the `except` block:

~~~{.python caption="main.py"}
try:
    prin(3/0)
except NameError:
    print(3/0)
~~~

Instead of silencing the exception you handled, Python indicates:

- The exception that it raises while you were handling another exception
- The exception that you handled.

This is indicated by the *During handling of the above exception, another exception occurred* statement in the traceback below :

~~~{ caption="Output"}
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
NameError: name 'prin' is not defined. Did you mean: 'print'?

During the handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "<stdin>", line 4, in <module>
ZeroDivisionError: division by zero
~~~

The `try and except` statement allows you to handle any type of exception class, however, it is limited because:

- Only a single exception is handled at a time
- It only executes the first `except` block that matches the exception.

This `exception` and `except` statement suffices in most use cases, however, there is a need for a feature that can handle multiple exceptions at a time and a feature that can trigger multiple different exceptions. These features will be [particularly useful in asynchronous programming](https://docs.python.org/3/library/asyncio-task.html#task-groups).

### ExceptionGroup and the Except* Statement

[PEP 654 specification](https://peps.python.org/pep-0654/) introduces the `ExceptionGroup` and the `except *` statement in the Python 3.11 version.

#### The `ExceptionGroup`

`ExceptionGroup` allows you to raise multiple exceptions at the same time.

Like regular exceptions, they are a subclass of the `Exception` class:

~~~{.python caption="main.py"}
print(issubclass(ExceptionGroup, Exception))
~~~

Output:

~~~{ caption="Output"}
true
~~~

And you can raise them with the `raise` statement:

~~~{.python caption="main.py"}

raise ExceptionGroup("exception groups", [ValueError(1), TypeError(2)]) 
~~~

You can also handle them with the `try and except` block (you should avoid using `except` with them as you will see later):

~~~{.python caption="main.py"}
try:
    raise ExceptionGroup("An exception group", [ValueError(), TypeError(1)])
except ExceptionGroup:
    print("I caught an exception group")
~~~

Output:

~~~{ caption="Output"}
I caught an exception group
~~~

Unlike regular exceptions, they take two arguments; the description of the error group and a sequence of exceptions (that needs to be raised at the same time). This sequence can include one or more exceptions of the same or different class, or even an exception group. The sequence cannot be empty though:

~~~{.python caption="main.py"}
ExceptionGroup("An exception group", [ValueError("a value error"), \
SyntaxError("a syntax error")])
~~~

If the sequence is empty, you will get the following output:

~~~{.python caption="main.py"}
print(ExceptionGroup("An exception group", []))
~~~

Output:

~~~{ caption="Output"}
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: second argument (exceptions) must be a non-empty sequence

~~~

The `ExceptionGroup` have an `exceptions` attribute that returns a tuple of the exception class in the sequence of exceptions:

~~~{.python caption="main.py"}

print(ExceptionGroup("An exception group", [ValueError("a value error"), \
SyntaxError("a syntax error")]).exceptions)
~~~

Output:

~~~{ caption="Output"}
(ValueError('a value error'), SyntaxError('a syntax error'))
~~~

When you raise them, the traceback shows a hierarchical structure of the exceptions in the group:

~~~{.python caption="main.py"}
raise ExceptionGroup("An exception group", \
[ValueError("a value error"), SyntaxError("a syntax error")])
~~~

Output:

~~~{ caption="Output"}
  + Exception Group Traceback (most recent call last):
  |   File "<stdin>", line 1, in <module>
  | ExceptionGroup: An exception group (2 sub-exceptions)
  +-+