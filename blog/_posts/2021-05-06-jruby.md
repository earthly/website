---
title: "JRuby vs Truffle Ruby vs MRI Ruby"
categories: 
  - Tutorial
toc: true 
author: Adam
---

Recently, I helped the Jekyll project with their continous intergration project. Jekyll is a static site generator created by github and written in Ruby. The Jekyll project has extensive tests running in the [continous integration pipeline] and tests across Ruby 2.7, Ruby 3 and JRuby.

JRuby testing was slowing the whole process down and this sort of surprized me: Wasn't the whole point of using JRuby and its new brother TruffleRuby to be faster?  It turns out that like many things the answer is complicated.


## What is JRuby?
> I was very happy to discover the JRuby project, my favorite programming language running on whatâ€™s probably the best virtual machine in the world. - Peter Lind

JRuby is Ruby that runs on the Java Virtual Machine (JVM).  Standard Ruby, also known as MRI Ruby, is written in C and has its own runtime.  

## Install and Using JRuby with rbenv

Install rbenv:
```
brew install rbenv
```
List possible install options:
```
rbenv install -l     
```
Install:
```
rbenv install jruby-9.2.16.0
```
Set a specifc project to use JRuby:
```
rbenv local jruby-9.2.16.0
```

## Why use JRuby?

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">OMG <a href="https://twitter.com/hashtag/JRuby?src=hash&amp;ref_src=twsrc%5Etfw">#JRuby</a> +Java.util.concurrent FTW! Doing a recursive backtrace through billion+, I&#39;ve made it 30,000x faster than 1.9.3. 30 THOUSAND.</p>&mdash; /dave/null (@bokmann) <a href="https://twitter.com/bokmann/status/381422498170273792?ref_src=twsrc%5Etfw">September 21, 2013</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>


## Performance
Ruby is known to be slow, as compared to Java or even optimized javascript.  According to the [The Computer Language Benchmarks Game](https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/pidigits.html) its often 5-10x slower than an Java solution.  Of course, the examples are not always comparing like to like, more on that later.  But one reason Java is fast is because of the amount of engineering time that has been spent on optimzing the JVM and therefore one reason you might want to use JRuby is to grab some of those optimizations for your Ruby program.

## Threading
This could be considered a subset of Performance.  MRI Ruby, much like Python, has a global interpreter lock.  This means that although you can have many threads in a single Ruby process, only one will ever be running at the time.  If you look at [many](https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/fannkuchredux.html) of the benchmark shoutout results, parallel multi-core solution dominate.  JRuby lets you run sidestep the GIL as a bottleneck, at the cost of having to worry about writing thread-safe code.


## Library Access and Environemnt Access
A common reason to use JRuby is that you need to use a java based library but would prefer to write Ruby, or already have an existing ruby codebase. My 2 cents is that if you are starting from scratch, and need to target the JVM JRuby should not be the first option you consider but if you do choose JRuby be warned that you are going to need a good grasp of Java, the JVM, and Ruby to successfully use Java libraries all from JRuby. Obviously, JRuby won't safe you from having to read and understand Java if your coming to the JVM for java libraries and functionality.  This is also a great case for considering TruffleRuby, but more on that later.


## Why is my JRuby Program Slow?
The JVM is not a performance panacea, it makes different performance trade-offs than MRI Ruby.  Notably an untuned JVM process has a slow start up time and with JRuby this can get even worse.  The JVM starts by working as an byte code interpreter and compiles "hot" code as it goes.

If you are using JRuby at the command line, or starting lots of short lived JRuby processes, it is likely that JRuby will be slower than MRI Ruby. However, the JVM is extensively tunable and its possible to tune things to behave more like standard Ruby.

If you want your JRuby to behave more like MRI Ruby, with reduced startup time your probably want to set the `--dev` flag.  Either like this:
```
 ENV JRUBY_OPTS="--dev"
 ```
 OR 
 ```
 jruby --dev file.rb
 ```

## Why is my JRuby Program Wrong?
Ruby's built-in types were built with the GIL in mind and have and are not thread safe on the JVM. If you get unexpected or non-determinstic results in your concurrent array usage you should look at concurrent datastructures for the JVM like ConcurrentHashMap or ConcurrentSkipListMap.  You may find that they not only fix the threading bugs but the correct structure could be [orders of magnitude faster](https://gist.github.com/bokmann/6652776) the idomatic ruby way.

## The Future: GraalVM And TruffleRuby

[GraalVM](https://www.graalvm.org/) is a JVM with different goals than the standard Java virtual machine.  According to wikipeida these goals are:
 * To improve the performance of Java virtual machine-based languages to match the performance of native languages.
 * To reduce the startup time of JVM-based applications by compiling them ahead-of-time with GraalVM Native Image technology.
 * To allow freeform mixing of code from any programming language in a single program.

Increased performance and better startup time sound exactly like what we need for JRuby and this fact did not go unnoticed: [TruffleRuby](https://github.com/oracle/truffleruby) is a fork of JRuby that runs on GraalVM.  Because GraalVM supports both ahead of time compilation and JIT, it possible to optimize either for peak performance - useful for long running services - or for startup time - useful for shorter running command-line apps or lambdas.

| Configuration: | Native (`--native`, default) | JVM (`--jvm`) |
| ------------------ | ------------: | ------------: |
| Time to start TruffleRuby | about as fast as MRI startup | slower |
| Time to reach peak performance | faster | slower |
| Peak performance (also considering GC) | good | best |
| Java host interoperability | needs reflection configuration | just works |

## Install TruffleRuby using rbenv

Install rbenv
```
brew install rbenv
```
List possible install options:
```
rbenv install -l     
```
Install 
```
rbenv install truffleruby+graalvm-21.0.0  
```

```
rbenv local truffleruby+graalvm-21.0.0  
```

```
ruby --version
truffleruby 21.0.0, like ruby 2.7.2, GraalVM CE Native [x86_64-darwin]
```

Set mode to `--native` 

```
ENV TRUFFLERUBYOPT='--native'
```

## Performance Shootout
In CPU heavy performance tests, TruffleRuby performance is signficantly better than JRuby, whose performance is again signifacntly better than MRI Ruby.  [PragToby](https://pragtob.wordpress.com/2020/08/24/the-great-rubykon-benchmark-2020-cruby-vs-jruby-vs-truffleruby/) has a great breakdown:

![Performance Of Ruby Runtimes from PragToby]({{site.images}}{{page.slug}}/2020_relative_speedup.png)

However, in my testing with Jekyll and the Jekyll CI Pipeline itself, but JRuby and TruffleRuby are significantly slower than using MRI Ruby. I think there are two reasons for this: One, real world projects like Jekyll involve a lot more code and JITing that code has a cost that leads to slower startups. Two: Real world code like Jekyll or Rails has been optimzed for MRI Ruby and many of those optimzations may actually lead to performance reductions in a runtime that makes different trade-offs. The most obvious place where you see this difference is that Ruby programs are often written in a multi-process style, where the GIL is not an issue and the fast start time of MRI Ruby is an advantage.  JVM Programs on the other hand are often written in a multi-threading style, where code only has to be JIT'd once and the start-up cost is only paid once.  And infact, if you ignore langauge shoot-out games, where everything is a single process and instead compare an MRI multi-process approach to TruffleRuby multi-threading approach a lot of advantages of the JVM seem to disappear for standard Ruby Code.

![MRI Ruby is close to TruffleRuby when Muli-Process]({{site.images}}{{page.slug}}/mri_truffle.png)


Something which I didn't see benchmark for was multi-process approach used in a large project. In that case I would expect MRI ruby to win hands down.  Which bring me back to my original question: Why is Jruby slow for Jekyll? 


Which leaves us with the most generic of performance advice: You should test your Ruby codebase with different runtimes and see what works best for your usecase.  

## More Resources
 * https://devcenter.heroku.com/articles/moving-an-existing-rails-app-to-run-on-jruby
 * https://gist.github.com/bokmann/6652776
 * https://pragtob.wordpress.com/2020/08/24/the-great-rubykon-benchmark-2020-cruby-vs-jruby-vs-truffleruby/
 * https://github.com/oracle/truffleruby/blob/master/README.md
 * https://www.youtube.com/watch?v=281YdMYRAsk