---
title: "Why is JRuby Slow?"
categories: 
  - Tutorial
toc: true 
author: Adam
---

Recently, I helped the Jekyll project with their continous intergration process. Jekyll is a static site generator created by github and written in Ruby. The Jekyll project has extensive tests running in the continous integration pipeline and tests across Ruby 2.5, 2.7, 3.0, and JRuby. The build times looked like this:


| Ruby Version       | Jekyll CI Time  |         
| ----------- |:-------------:|
| 2.5      |   8m 31s |
| 2.7      | 8m 33s     |
| 3.0      |  7m 47s    |
| JRuby    |  45m 16s    |
<figcaption>A Representative Jekyll CI [Build](https://github.com/jekyll/jekyll/runs/2048545456?check_suite_focus=true)</figcaption>

JRuby was slowing the whole process down and this sort of surprized me: Wasn't the whole point of using JRuby, and its new brother TruffleRuby, speed?  Why was JRuby so slow? In this essay I am going to attempt to answer that question. It turns out that like many things the answer is complicated. 

## What is JRuby?
> I was very happy to discover the JRuby project, my favorite programming language running on whatâ€™s probably the best virtual machine in the world. - Peter Lind

JRuby is Ruby that runs on the Java Virtual Machine (JVM).  Standard Ruby, also known as MRI Ruby, is written in C and has its own runtime.  

### Install and Using JRuby with rbenv

On my mac book, I can switch from the standard Ruby runtime to JRuby like this.

Install rbenv:
```
brew install rbenv
```
List possible install options:
```
rbenv install -l     
```
Install:
```
rbenv install jruby-9.2.16.0
```
Set a specifc project to use JRuby:
```
rbenv local jruby-9.2.16.0
```

## Why do people use JRuby?

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">OMG <a href="https://twitter.com/hashtag/JRuby?src=hash&amp;ref_src=twsrc%5Etfw">#JRuby</a> +Java.util.concurrent FTW! Doing a recursive backtrace through billion+, I&#39;ve made it 30,000x faster than 1.9.3. 30 THOUSAND.</p>&mdash; /dave/null (@bokmann) <a href="https://twitter.com/bokmann/status/381422498170273792?ref_src=twsrc%5Etfw">September 21, 2013</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

There are several reasons people might choose JRuby, several of which have to do with performance.

### Getting past the GIL
MRI Ruby, much like Python, has a global interpreter lock.  This means that although you can have many threads in a single Ruby process, only one will ever be running at the time.  If you look at [many](https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/fannkuchredux.html) of the benchmark shoutout results, parallel multi-core solution dominate.  JRuby lets you sidestep the GIL as a bottleneck, at the cost of having to worry about writing thread-safe code.

### Library Access and Environment Access
A common reason to use JRuby is that you need to use a Java based library but would prefer to write in Ruby, or already have an existing Ruby codebase. My 2 cents is that if you are starting from scratch, and need to target the JVM, JRuby should not be the first option you consider but if you do choose JRuby be warned that you are going to need a good grasp of Java, the JVM, and Ruby. Obviously, JRuby won't safe you from having to read and understand Java if your coming to the JVM for java libraries and functionality.

### Long Running Process Performance
Ruby is known to be slow, as compared to Java or even optimized javascript.  According to the [The Computer Language Benchmarks Game](https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/pidigits.html) its often 5-10x slower than an Java solution.  Of course, the examples are not always comparing like to like, more on that later.  However, one place the JVM is known to perform very well compared to interpreted langauages is in long running server applications, where [adaptive optimzations](https://jakubstransky.com/2018/08/28/hotspot-jvm-jit-optimisation-techniques/) can make a big difference.  

## Why is my JRuby Program Slow though?
The JVM is not a performance panacea, it makes different performance trade-offs than MRI Ruby.  Notably an untuned JVM process has a slow start up time and with JRuby this can get even worse, as lots of standard library code is loaded on startup.  The JVM starts by working as an byte code interpreter and compiles "hot" code as it goes but in a large Ruby project, with lots of gems, the overhead of JITing all this can lead to a significantly slower start up time.

If you are using JRuby at the command line, or starting lots of short lived JRuby processes, it is likely that JRuby will be slower than MRI Ruby. However, the JVM is extensively tunable and its possible to tune things to behave more like standard Ruby.

If you want your JRuby to behave more like MRI Ruby, with reduced startup time your probably want to set the `--dev` flag.  Either like this:
```
 ENV JRUBY_OPTS="--dev"
 ```
 OR 
 ```
 jruby --dev file.rb
 ```

In my usecase, speeding up the Jenkins build, this change and some other JVM parameter tweaking made a big difference.  I was able to get the build time down from 45m 16s to 24m 1s.

| Ruby        | Time           
| ----------- |:-------------:|
| JRuby    |  45m 16s    |
| JRuby --dev |  24m 1s    |

<figcaption>`--dev` gets us closer to MRI Ruby</figcaption>

## Why is my JRuby Program Wrong?
Ruby's built-in types were built with the GIL in mind and are not thread safe on the JVM. If you move the JRuby to sidestep the GIL, keep in mind that you may be introducing threading bugs.  If you get unexpected or non-determinstic results in your concurrent array usage you should look at concurrent datastructures for the JVM like ConcurrentHashMap or ConcurrentSkipListMap.  You may find that they not only fix the threading bugs but the correct structure could be [orders of magnitude faster](https://gist.github.com/bokmann/6652776) the idomatic ruby way. In my case, Jekyll is not multi-threaded, so this is not an issue I needed to be concerned about.

## What is TruffleRuby?

[GraalVM](https://www.graalvm.org/) is a JVM with different goals than the standard Java virtual machine.  
According to wikipeida these goals are:

 * To improve the performance of Java virtual machine-based languages to match the performance of native languages.
 * To reduce the startup time of JVM-based applications by compiling them ahead-of-time with GraalVM Native Image technology.
 * To allow freeform mixing of code from any programming language in a single program.

Increased performance and better startup time sound exactly like what we need to improve on JRuby and this fact did not go unnoticed: [TruffleRuby](https://github.com/oracle/truffleruby) is a fork of JRuby that runs on GraalVM.  Because GraalVM supports both ahead of time compilation and JIT, it possible to optimize either for peak performance - useful for long running services - or for startup time - useful for shorter running command-line apps like Jekyll.

TruffleRuby explains the trade-offs of AOT vs JIT like this:

| Configuration: | Native (`--native`, default) | JVM (`--jvm`) |
| ------------------ | ------------: | ------------: |
| Time to start TruffleRuby | about as fast as MRI startup | slower |
| Time to reach peak performance | faster | slower |
| Peak performance (also considering GC) | good | best |
| Java host interoperability | needs reflection configuration | just works |

### Install TruffleRuby using rbenv

Install rbenv
```
brew install rbenv
```
List possible install options:
```
rbenv install -l     
```
Install 
```
rbenv install truffleruby+graalvm-21.0.0  
```

```
rbenv local truffleruby+graalvm-21.0.0  
```

```
ruby --version
truffleruby 21.0.0, like ruby 2.7.2, GraalVM CE Native [x86_64-darwin]
```

Set mode to `--native` 

```
ENV TRUFFLERUBYOPT='--native'
```

## Performance Shootout
In CPU heavy performance tests, TruffleRuby performance is signficantly better than JRuby, whose performance is again signifacntly better than MRI Ruby accoring to benchmark tests.  [PragToby](https://pragtob.wordpress.com/2020/08/24/the-great-rubykon-benchmark-2020-cruby-vs-jruby-vs-truffleruby/) has a great breakdown:

![Performance of JVM Ruby runtimes in small tests looks good but is it too good to be true?]({{site.images}}{{page.slug}}/2020_relative_speedup.png)

However, in my testing with Jekyll and the Jekyll CI Pipeline itself, but JRuby and TruffleRuby are significantly slower than using MRI Ruby. How can this be?

I think there are two reasons for this: 

1. Real-World projects like Jekyll involve a lot more code and JITing that code has a significant startup cost. 
2. Real-world code like Jekyll or Rails has been optimzed for MRI Ruby and many of those optimzations may actually lead to performance reductions in a runtime that makes different trade-offs. 
 
The most obvious place where you see this difference is that Ruby programs are often written in a multi-process style, where the GIL is not an issue and the comparatively fast start time of MRI Ruby is an advantage.  JVM Programs on the other hand are often written in a multi-threading style, where code only has to be JIT'd once and the start-up cost is only paid once.  And infact, if you ignore langauge shoot-out games, where everything is a single process and instead compare an MRI multi-process approach to TruffleRuby multi-threading approach a lot of advantages of the JVM seem to disappear for standard Ruby Code.

![Multi-process MRI Ruby is close to in performance to TruffleRuby in the JVM's Sweatspot]({{site.images}}{{page.slug}}/mri_truffle.png)

This chart comes from [Benoit Daloze](https://github.com/eregon)[^1] the TruffleRuby lead. This is a long running server side application using a minimal web framework so it is generallly in the sweatspot of the GRAALVM and of TruffleRuby, with little code to JIt and much time to make up for the slow start but even so MRIRuby is pretty close in performance.

Which brings me back to my original question: Why is JRuby slow for Jekyll?  Jekyll is not forking processes, so that is not the issue.  Hugo, the static site builder for Go is signifcantly faster than Jekyll so we know that Jekyll is not at the pareto front of effiecency where there is simply no more performance to squeeze. To dig in, lets take a look at a flamegraph of the Jekyll build for this blog using RubySpy:

### Test with RubySpy

```
sudo RUBYOPT='-W0' rbspy record -- bundle exec jekyll build --profile
```

![A Flame Graph shows must time is File Access]({{site.images}}{{page.slug}}/flame-graph.png)

What we see is that 50% of the wall time is spent here:
``` ruby
    # Write static files, pages, and posts.
    #
    # Returns nothing.
    def write
      each_site_file do |item|
        item.write(dest) if regenerator.regenerate?(item)
      end
      regenerator.write_metadata
      Jekyll::Hooks.trigger :site, :post_write, self
    end
```
16% of time is spent here:
```
    # Read Site data from disk and load it into internal data structures.
    #
    # Returns nothing.
    def read
      reader.read
      limit_posts!
      Jekyll::Hooks.trigger :site, :post_read, self
    end
```
Only 22% of time is spent here, doing the actual work of generating HTML:

```
    # Render the site to the destination.
    #
    # Returns nothing.
    def render
      relative_permalinks_are_deprecated

      payload = site_payload

      Jekyll::Hooks.trigger :site, :pre_render, self, payload

      render_docs(payload)
      render_pages(payload)

      Jekyll::Hooks.trigger :site, :post_render, self, payload
    end
```
In otherwords, all the time is spent reading to and from disk.  Clearly the hugo case shows us this IO can be done faster in other languages: we aren't hitting a hardware limit. Yet why does this run even slower in JRuby and Truffle Ruby than it does in MRI Ruby?  My conclusion from this is that filesystem Ruby code does not benefit from being on the JVM, on the contrary, it seems to run slower on the JVM.  I'm guessing it would be possible to reimplement write and read to follow JVM high-performace file access best practices and get a speed up for Jekyll that way, but I'm not sure if that would bring make JRuby faster than MRI Ruby for Jekyll or just bring it to a similar speed. 

Which leaves me with the most generic of performance advice: You should test your Ruby codebase with different runtimes and see what works best for your usecase.  If you code is long running, CPU bound, and thread based, and if you are limited by the GIL, TruffleRuby will probably be a win.  Also, if that is the case and you tweak your code to use java concurrent datastructures instead of Ruby defaults you can probably achieve order of magnitude speed ups. However, if your existing ruby code base is not CPU bound and not multi-threaded and uses a lot of gems which add to the amount of code to JIT, well then it will probably run slower on JRuby and Truffle Ruby. 

Also a caveat: It is possible I missed something here, I am just a guy on the internet trying to answer the question "Why does JRuby exist if it is actually slower when I use it?" 

## More Resources
 * https://devcenter.heroku.com/articles/moving-an-existing-rails-app-to-run-on-jruby
 * https://gist.github.com/bokmann/6652776
 * https://pragtob.wordpress.com/2020/08/24/the-great-rubykon-benchmark-2020-cruby-vs-jruby-vs-truffleruby/
 * https://github.com/oracle/truffleruby/blob/master/README.md
 * https://www.youtube.com/watch?v=281YdMYRAsk

[^1]: The work behind JRuby, GraalVM and TruffleRuby is amazing. The TruffleRuby benchmark numbers for CPU heavy work continue to improve year upon year. I'm not trying to dunk on the great work that has been done. Merely trying to investigate why I was seeing a slow down.