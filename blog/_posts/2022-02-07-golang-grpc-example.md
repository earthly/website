---
title: "Golang gRPC Example"
categories:
  - Tutorials
toc: true
author: Adam
sidebar:
  nav: "activity-tracker"
internal-links:
 - golang grpc
 - grpc server
 - golang grpc server
 - grpc tutorial
 - grpc client
 - golang grpc client
 - grpcurl
 - grpcurl examples
 - protoc
 - protoc-gen-go
 - protobuf vs json

---
<!-- markdownlint-disable MD036 -->
Welcome back. I'm an experienced developer, learning Golang by building an activity tracker. Last time I added sqlite persistance. Today, I'm going to be porting everything to gRPC.

If you're curious about gRPC – how it works, when to use it, what example code might look like –  well you are in luck because I'm going to be building a grpc client, a grpc server and the protobuf files for my activity tracker. The full code is here.

## Why gRPC

If the main client of your backend service is client side JavaScript or if your project is going to have many clients, some of which you won't control then a JSON based REST service is a great way to go. JSON is human readable, its simple to make requests at the command-line or using tools like postman, and its a well understood how to write good REST apis. 

However, it has some downsides. JSON is a text format, so there is more data to send and it is more expensive to serialize and deserialize. A standardized API specification does exist ( OpenAPI 2.0 aka Swagger 2.0 ) but generating a client and server from the specification is a bit trickier. 

gRPC addresses a lot of these issues. It's binary format, so its quicker to send. It's quicker to serialize and de-serialize and it has better type support than JSON. But the most important aspect for my little app is that gRPC has code-generation. I can describe my service using `.proto` files and use existing tool to do some of the heavy lifting.

## Protocal Buffers
One of the big advantages to gRPC is protocol buffers, called protobuf from here forward. With protobufs you can encode the message semantics in a parsable form that can be shared among client and service. Protobuffs are a platform neutral language for structing data with built it fast serialization and support for schema migration, which is important if you want to change your message formats without introducing downtime.


First thing I'll do is create a message type:

~~~{.protobuf caption="api/v1/activity.proto"}
syntax = "proto3";

package api.v1;

import "google/protobuf/timestamp.proto";

message Activity {
    int32 id = 1;
    google.protobuf.Timestamp time = 2;
    string description = 3;
}
~~~

A couple things to note is this short example. First off I am using the latest version of the protobuf syntax `proto3`. Second I'm specifiying a package name `package api.v1;` and this will get used in the code I'm generating.
Then I'll install the protobuf compiler:

~~~{.bash caption=">_"}
brew install protobuf
~~~

Make sure installed:

~~~{.bash caption=">_"}
protoc --version
~~~

~~~{.bash caption="Output"} 
libprotoc 3.19.4
~~~

Then I can use it to generate the go struct for the message type:

~~~{.bash caption=">_"}
 protoc activity-log/api/v1/*.proto \
    --go_out=. \
    --go_opt=paths=source_relative \
    --proto_path=.
~~~

~~~{.bash caption="Output"} 

Please specify a program using absolute path or make sure the program is available in your PATH system variable
--go_out: protoc-gen-go: Plugin failed with status code 1.
~~~

First it seems I need protoc-gen-go:

~~~{.bash caption=">_"}
$ brew install grpc 
$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.26
~~~

And I need to add it to my path:

~~~{.bash caption="~/.zshrc"}
export PATH="$PATH:$(go env GOPATH)/bin"
~~~

With that installed, I can successfully generate some code 

~~~{.bash caption=">_"}
 protoc activity-log/api/v1/*.proto \
    --go_out=. \
    --go_opt=paths=source_relative \
    --proto_path=.
~~~

And I get an activity struct that I can use in my service and client:

~~~{.go caption="api/v1/activity.pb.go"}
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.26.0
// 	protoc        v3.19.4
// source: activity-log/api/v1/activity.proto

package api_v1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
)

type Activity struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id          int32                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Time        *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=time,proto3" json:"time,omitempty"`
	Description string                 `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
}
~~~

`protoc` also generates a number of helper methods for working with the protobug message, such as field getters:

~~~{.go caption="api/v1/activity.pb.go"}
func (x *Activity) GetTime() *timestamppb.Timestamp {
	if x != nil {
		return x.Time
	}
	return nil
}

func (x *Activity) GetId() int32 {
	if x != nil {
		return x.Id
	}
	return 0
}
~~~

These are helping me correctly handle zero values on a nil Activity. I'm not sure why I'd be asking for the values of a nil Activity, but maybe it will make sense later.

Now that I have things working for one message type, I can define my whole service:

~~~{.protobuf caption="api/v1/activity.proto"}
service Activity_Log {
    rpc Insert(Activity) returns (InsertResponse) {}
    rpc Retrieve(RetrieveRequest) returns (Activity) {}
    rpc List(ListRequest) returns (Activities) {}
}

message RetrieveRequest {
    int32 id = 1;
}

message InsertResponse {
    int32 id = 1;
}

message ListRequest {
    int32 offset = 1;
}

message Activities {
    repeated Activity activities = 1;
}

message ActivityQuery {
	int32 offset = 1;
}
~~~

I can then generate the client and the service code using `protoc` again.

~~~{.bash caption=">_"}
 protoc activity-log/api/v1/*.proto \
    --go-grpc_out=. \
    --go-grpc_opt=paths=source_relative \
    --proto_path=.
~~~

Running this generates `activity_grpc.pb.go` with all the nessary code for a client and a server. 

Note how this time I used `go-grpc_out` and `go-grpc_opt=paths` instead of `go_out` and `go_opt=paths`. I can combine these two together to generate messages and the client server.  

~~~{.bash caption=">_"}
  protoc activity-log/api/v1/*.proto \
    --go_out=. \
    --go_opt=paths=source_relative \
    --go-grpc_out=. \
    --go-grpc_opt=paths=source_relative \
    --proto_path=.
~~~

<div class="notice">
**Side Note: OpenAPI Code Generation**

Generating code from an API specification is great, especially if you are working on a project where the client and server are being built by different people or even different teams.

In the past, when building REST clients in Scala, I've used OpenAPI specs as the source of truth and generated code from them, so the approach `protoc` is helping me use is not merely limited to gRPC. 

A great solution for writing REST clients from an OpenAPI definitions is [gaurdrail](https://github.com/guardrail-dev/guardrail) if you are using Scala. In goLang, gRPC seems much more common, but [go-swagger](https://github.com/go-swagger/go-swagger) looks pretty promising if you want a REST service.

Another possible path to generating a REST client is [grpc-gateway](https://github.com/grpc-ecosystem/grpc-gateway). If I need a rest endpoints in addition to the gRPC end-points, then I may give that a try.

</div>

## Golang gRPC Server

Now that I've got all my code generated, its time for me to build the server side. Let's start at the database layer and work upwards

If you recall from when I was adding the `sqlite` feature, Activities handles all the data persistence. The data persistence should change at all. I just need to make sure I'm using my `protoc` generated struct. I can do this with an import change:

~~~{.diff caption="activity-log/internal/server/activity.go "}
import 
- api "github.com/adamgordonbell/cloudservices/activity-log"
+ api "github.com/adamgordonbell/cloudservices/activity-log/api/v1"
+ "google.golang.org/protobuf/types/known/timestamppb"
~~~

### `google.protobuf.Timestamp`

Previsouly my Activity struct was using `time.Time` to represent time and "net/http" was mapping it back and forth to a JSON string. However, protobufs are typed and so I have choosen to use `google.protobuf.Timestamp` as my datetime type. This means I need to worry less about getting invalid data.

Unfortunely, my generated code now uses a `google.protobuf.Timestamp` where my persistenance layer needs a `time.Time`. This is easy to fix with
This is easy to fix with `AsTime`:

~~~{.go caption="timstamp.pb.go"}
// AsTime converts x to a time.Time.
func (x *Timestamp) AsTime() time.Time {
       return time.Unix(int64(x.GetSeconds()), int64(x.GetNanos())).UTC()
}
~~~

<br/>

~~~{.diff captionb="activity-log/internal/server/activity.go"}
func (c *Activities) Insert(activity *api.Activity) (int, error) {
	res, err := c.db.Exec("INSERT INTO activities VALUES(NULL,?,?);", 
-  activity.Time, 
+  activity.Time.AsTime(), 
  activity.Description)
	if err != nil {
		return 0, err
	}
~~~

And that is really the only perstiecne layer change we need to make to switch from our hand-rolled struct to the `protoc` generated one. You can see the full file here: TODO


## GRPC Service

Previously, in my http service, I had an `httpServer`, I'm going to rename that::

~~~{.diff caption="activity-log/internal/server/server.go"}
- type httpServer struct {
+ type grpcServer struct {
	Activities *Activities
}
~~~

And then I need to make an instance of it:

~~~{.go caption="activity-log/internal/server/server.go"}
func NewGRPCServer() *grpc.Server {
	var acc *Activities
	var err error
	if acc, err = NewActivities(); err != nil {
		log.Fatal(err)
	}
	gsrv := grpc.NewServer()
	srv := grpcServer{
		Activities: acc,
	}
	api.RegisterActivity_LogServer(gsrv, &srv)
	return gsrv
}
~~~
ToDO: explain why this returns grpc.Server

And then wire that up to my main method and I can start things up:

~~~{.go caption="activity-log/cmd/server/main.go"}
func main() {
	log.Println("Starting listening on port 8080")
	port := ":8080"

	lis, err := net.Listen("tcp", port)
	if err != nil {
		log.Fatalf("failed to listen: %v", err)
	}
	log.Printf("Listening on %s", port)
	srv := server.NewGRPCServer()

	if err := srv.Serve(lis); err != nil {
		log.Fatalf("failed to serve: %v", err)
	}
}

~~~
I haven't written an implementation of any of the RPC methods yet, but I'm curious what happens if I run it. 

Actually I can't even get that far, it won't compile, but it does give me this helpful error message:

~~~{.bash caption=">_"}
$ go run cmd/server/main.go

~~~

~~~{.bash caption="Output"}
# github.com/adamgordonbell/cloudservices/activity-log/internal/server
internal/server/server.go:30:39: cannot use &srv (type *grpcServer) as type api_v1.Activity_LogServer in argument to api_v1.RegisterActivity_LogServer:
        *grpcServer does not implement api_v1.Activity_LogServer (missing api_v1.mustEmbedUnimplementedActivity_LogServer method)
~~~

All I need to do is add an `UnimplementedActivity_LogServer`:

~~~{.diff caption="activity-log/internal/server/server.go"}
 type grpcServer struct {
+	api.UnimplementedActivity_LogServer
 	Activities *Activities
 }
~~~

And with that I can start running things:

~~~{.bash caption=">_"}
grpcurl -plaintext -d  '{ "description": "christmas eve bike class" }' \
 localhost:8080 api.v1.Activity_Log/Insert
~~~

~~~{.bash caption="Output"}
ERROR:
  Code: Unimplemented
  Message: method Insert not implemented
~~~

How does that work? How can I call the method that I haven't implemented yet? Well, the `protoc` generated code contains `UnimplementedActivity_LogServer` which looks like this:

~~~{.go captionb="activity-log/api/v1/activity_grpc.pb.go"}
// UnimplementedActivity_LogServer must be embedded to have forward compatible implementations.
type UnimplementedActivity_LogServer struct {
}
~~~

But, it also implements this interface:

~~~{.go caption="activity-log/api/v1/activity_grpc.pb.go"}
type Activity_LogServer interface {
	Insert(context.Context, *Activity) (*InsertResponse, error)
	Retrieve(context.Context, *RetrieveRequest) (*Activity, error)
	List(context.Context, *ListRequest) (*Activities, error)
	mustEmbedUnimplementedActivity_LogServer()
}
~~~

and those implementations are what I'm hitting when I call `insert`:

~~~{.go captionb="activity-log/api/v1/activity_grpc.pb.go"}
func (UnimplementedActivity_LogServer) Insert(context.Context, *Activity) (*InsertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
~~~
As a newcomer to GoLang, its actually pretty nice that I can just read through the generated code and understand how it works. 

<div class="notice--info">
**Making gRPC requests by Hand**

There is one potential downside to using gRPC instead of rest: they are less human readable. With REST, I can make a GET request in my browser and view the JSON result and I can use curl and related tools to make more complex requests. This is harder to do with gRPC and protobufs. Or at least it used to be. I've found working with gRPC at the command line is doable once I did a couple of steps:

### 1) Install `grpcurl` 

~~~{.bash caption=">_"}
brew install grpcurl
~~~

### 2) Enable Reflection

~~~{.diff caption="main.go"}
func main() {
	...
	srv := server.NewGRPCServer()
+	// Register reflection service on gRPC server.
+	reflection.Register(srv)
	if err := srv.Serve(lis); err != nil {
		log.Fatalf("failed to serve: %v", err)
	}
}
~~~

Then you can not only make called against the service like its a REST service:

~~~{.bash caption=">_"}
$ grpcurl -plaintext -d  \
  '{ "description": "christmas eve bike class" }' \
  localhost:8080 api.v1.Activity_Log/Insert
~~~
~~~{.bash caption="Output"}
{
  "id": 1
}
~~~

And even better, you can introspect against the service and see what gRPC methods it implements:

~~~{.bash caption=">_"}
grpcurl -plaintext localhost:8080 describe
~~~

~~~{.protobuf caption="Output"}
api.v1.Activity_Log is a service:
service Activity_Log {
  rpc Insert ( .api.v1.Activity ) returns ( .api.v1.InsertResponse );
  rpc List ( .api.v1.ListRequest ) returns ( .api.v1.Activities );
  rpc Retrieve ( .api.v1.RetrieveRequest ) returns ( .api.v1.Activity );
}
~~~

Without reflection on you would get an error like this:

~~~{.bash caption=">_"}
grpcurl -plaintext localhost:8080 describe
Error: server does not support the reflection API
~~~

`grpc_cli` which comes with grpc also can use the reflection api:

~~~{.bash caption=">_"}
grpc_cli ls localhost:8080 -l
~~~
~~~{.protobuf caption="Output"}
filename: activity-log/api/v1/activity.proto
package: api.v1;
service Activity_Log {
  rpc Insert(api.v1.Activity) returns (api.v1.Activity) {}
  rpc Retrieve(api.v1.RetrieveRequest) returns (api.v1.Activity) {}
  rpc List(api.v1.ListRequest) returns (api.v1.Activities) {}
}
~~~

And you aren't strictly limited to grpcurl or the command-line. I like grpcurl because it works like, well curl, but many other options exist. Postman supports grpc, as does [BloomRPC](https://github.com/bloomrpc/bloomrpc), [Insomnia](https://insomnia.rest/) and [many](github.com/gogo/letmegrpc) [command-line](https://github.com/fullstorydev/grpcui) [tools](https://github.com/gusaul/grpcox).

</div>

### gRPC Service Implementation

So as it stands now, the database layer is done, and the service can start up and receive gRPC requests but there is not service implementation connecting these two parts together. Let's write that.

The interface tells me what I need to do for each function. Insert looks like this:

~~~{.go caption="activity-log/api/v1/activity_grpc.pb.go"}
Insert(context.Context, *Activity) (*InsertResponse, error)
~~~

And I can implement it by just calling through to my database layer, handling the error conditions and wrapping the response back up in the expected type:

~~~{.go caption="activity-log/internal/server/server.go"}
func (s *grpcServer) Insert(ctx context.Context, activity *api.Activity) (*api.InsertResponse, error) {
	id, err := s.Activities.Insert(activity)
	if err != nil {
		return nil, fmt.Errorf("Internal Error: %w", err)
	}
	res := api.InsertResponse{Id: int32(id)}
	return &res, nil
}
~~~

I can repeat this for `List` and `Retrieve` (full code on github) and I have a working solution. (Though there is room for improvement, that I'll get back to in a second).

## Testing A gRPC Server

Previously, I had tested my REST service, by starting it up in a docker container and exercising some endpoints via a small bash script `test.sh`. And ran it all in an Earthfile in GitHubActions that looked like this:

~~~{.dockerfile caption="Earthfile"}
test:
    FROM +test-deps
    COPY test.sh .
    WITH DOCKER --load agbell/cloudservices/activityserver=+docker
        RUN  docker run -d -p 8080:8080 agbell/cloudservices/activityserver && \
                ./test.sh
    END
~~~

To get this working with grpc, all I need to do is change `test.sh` to use `grpcurl`:

~~~{.bash caption=">_"}
# echo "=== Test Reflection API ==="
grpcurl -plaintext localhost:8080 describe

echo "=== Insert Test Data ==="

grpcurl -plaintext -d  '{ "description": "christmas eve bike class" }' localhost:8080 api.v1.Activity_Log/Insert

echo "=== Test Retrieve Descriptions ==="

grpcurl -plaintext -d '{ "id": 1 }' localhost:8080 api.v1.Activity_Log/Retrieve | grep -q 'christmas eve bike class'

echo "=== Test List ==="

grpcurl -plaintext localhost:8080 api.v1.Activity_Log/List | jq '.activities | length' |  grep -q '1'

echo "Success"
~~~

And additionally, I need to make sure my `+test-deps` container has `grpcurl` installed. There are probably lots of ways to get grpcurl into my alpine base image, but the way I did it was just copy it from the official grpcurl alpine image into my `test-deps` image:

~~~{.diff caption="Earthfile"}
+ grpcurl:
+    FROM fullstorydev/grpcurl:latest
+    SAVE ARTIFACT /bin/grpcurl ./grpcurl

 test-deps:
     FROM earthly/dind
     RUN apk add curl jq
+    COPY +grpcurl/grpcurl /bin/grpcurl
~~~

And with that my gRPC server example is working and has end-to-end tests running in CI.

<div class="wide">
{% picture content-wide-nocrop {{site.pimages}}{{page.slug}}/3040.png --alt {{ gRPC Server Example Working  }} %}
<figcaption>gRPC Server Example Working</figcaption>
</div>

Now I can move on to the gRPC client example.

## Golang gRPC Client Example

How does the client code get generated? It turns out that is generated using `protoc` just like the service. In fact, I've already generated it without realizing it. 

`protoc` created the client code when given `--go-grpc_out`:

~~~{.bash caption=">_"}
    protoc activity-log/api/v1/*.proto \
    --go_out=. \
    --go_opt=paths=source_relative \
    --go-grpc_out=. \
    --go-grpc_opt=paths=source_relative \
    --proto_path=.
~~~

It looks like this:

~~~{.go caption="activity-log/api/v1/activity_grpc.pb.go"}
type activity_LogClient struct {
	cc grpc.ClientConnInterface
}

func NewActivity_LogClient(cc grpc.ClientConnInterface) Activity_LogClient {
	return &activity_LogClient{cc}
}
~~~

My Activities client is going to contain an instance of this client:

~~~{.go caption="activity-client/internal/client/activity.go}
type Activities struct {
	client api.Activity_LogClient
}
~~~

And I'll initialize the client with an active connection like this:

~~~{.go caption="activity-client/internal/client/activity.go"}
func NewActivities(URL string) Activities {
	conn, err := grpc.Dial(URL, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		log.Fatalf("did not connect: %v", err)
	}
	client := api.NewActivity_LogClient(conn)
	return Activities{client: client}
}
~~~

Back in my main method, I initialze the client and also create a context. This context lets the client track if the request is still running. I'm creating mine with a timeout so my service can't hang my client if something goes sideways.

~~~{.go bcaption="activity-client/cmd/client/main.go"}
ctx, cancel := context.WithTimeout(context.Background(), time.Second)
defer cancel()
~~~

<div class="notice--info">
Breaking the client

Problem:
~~~{.bash caption=">_"}
go run cmd/client/main.go -get 3
Error: Insert failure: rpc error: code = Canceled desc = context canceled
exit status 1
~~~
Solution:
~~~{.bash caption=">_"}
I had called defer cancel in my constructor.
~~~

Problem:
~~~{.bash caption=">_"}
go run cmd/client/main.go -get 1
Error: Insert failure: rpc error: code = Canceled desc = grpc: the client connection is closing
exit status 1
~~~
Problem here was I closed the connection

</div>

To implement the calls to the client, I just call the client and handle any possible errors. Here is insert:

~~~{.go caption="activity-client/internal/client/activity.go"}
func (c *Activities) Insert(ctx context.Context, activity *api.Activity) (int, error) {
	resp, err := c.client.Insert(ctx, activity)
	if err != nil {
		return 0, fmt.Errorf("Insert failure: %w", err)
	}
	return int(resp.GetId()), nil
}
~~~

Did I say handle errors? That is where things get a little trickier. In a REST service, I can infer meaning from response codes. Insert, shown above, is pretty simple but when implementing `Retrieve` I'd like to differentiate between a server error and a id not existing. That was easy with Rest, I had 404s and 500s. 

It turns out gRPC has something similar. 

## gRPC Error Codes



I was wondering how the client was going to work. , but actually its already been generated, and I can use it.

# Explain about protobufs
# Aside about json verification and golang

## CLI protobufs





Now I just have to implement this interface:

~~~{.bash caption=">_"}
// Activity_LogServer is the server API for Activity_Log service.
// All implementations must embed UnimplementedActivity_LogServer
// for forward compatibility
type Activity_LogServer interface {
	Insert(context.Context, *Activity) (*Activity, error)
	Retrieve(context.Context, *RetrieveRequest) (*Activity, error)
	List(context.Context, *ListRequest) (*Activities, error)
	mustEmbedUnimplementedActivity_LogServer()
}
~~~

not clear how `mustEmbedUnimplementedActivity_LogServer` works.


## Client





## Base stuff

This client here is helpful:
https://github.com/grpc/grpc-go/blob/master/examples/helloworld/greeter_client/main.go

First I have to connect to the client
~~~{.bash caption=">_"}

~~~

Then I can write my insert like this:
~~~{.bash caption=">_"}

~~~
and use it like this:
~~~{.bash caption=">_"}
~~~


# Error handling
By default your errors will only have a string description, but you
may want to include more information such as a status code or some other
arbitrary data.


We do this like this
NB: need code above this to not use status
~~~{.bash caption=">_"}
old:
return nil, fmt.Errorf("Internal Error: %w", err)

new:
		return nil, status.Error(codes.NotFound, "id was not found")

~~~

then we can unwrap it like this:
~~~{.bash caption=">_"}

~~~

## Questions
 - when to use int, int32, uint64 ?
 - what about hte locks and the pointers and stuff
