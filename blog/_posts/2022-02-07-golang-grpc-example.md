---
title: "Golang gRPC Example"
categories:
  - Tutorials
toc: true
author: Adam
sidebar:
  nav: "activity-tracker"
internal-links:
 - golang grpc
 - grpc server
 - golang grpc server
 - grpc tutorial
 - grpc client
 - golang grpc client
 - grpcurl
 - grpcurl examples
 - protoc
 - protoc-gen-go
 - protobuf vs json

---
<!-- markdownlint-disable MD036 -->
Welcome back. I'm an experienced developer, learning Golang by building an activity tracker. Last time I added sqlite persistance. Today, I'm going to be porting everything to gRPC.

If you're curious about gRPC – how it works, when to use it, what example code might look like –  well you are in luck because I'm going to be building a grpc client, a grpc server and the protobuf files for my activity tracker. The full code is here.

## Why gRPC

If the main client of your backend service is client side JavaScript or if your project is going to have many clients, some of which you won't control then a JSON based REST service is a great way to go. JSON is human readable, its simple to make requests at the command-line or using tools like postman, and its a well understood how to write good REST apis. 

However, it has some downsides. JSON is a text format, so there is more data to send and it is more expensive to serialize and deserialize. A standardized API specification does exist ( OpenAPI 2.0 aka Swagger 2.0 ) but generating a client and server from the specification is a bit trickier. 

gRPC addresses a lot of these issues. It's binary format, so its quicker to send. It's quicker to serialize and de-serialize and it has better type support than JSON. But the most important aspect for my little app is that gRPC has code-generation. I can describe my service using `.proto` files and use existing tool to do some of the heavy lifting.

## Protocal Buffers
One of the big advantages to gRPC is protocol buffers, called protobuf from here forward. With protobufs you can encode the message semantics in a parsable form that can be shared among client and service. Protobuffs are a platform neutral language for structing data with built it fast serialization and support for schema migration, which is important if you want to change your message formats without introducing downtime.


First thing I'll do is create a message type:

~~~{.protobuf caption="api/v1/activity.proto"}
syntax = "proto3";

package api.v1;

import "google/protobuf/timestamp.proto";

message Activity {
    int32 id = 1;
    google.protobuf.Timestamp time = 2;
    string description = 3;
}
~~~

A couple things to note is this short example. First off I am using the latest version of the protobuf syntax `proto3`. Second I'm specifiying a package name `package api.v1;` and this will get used in the code I'm generating.
Then I'll install the protobuf compiler:

~~~{.bash caption=">_"}
brew install protobuf
~~~

Make sure installed:

~~~{.bash caption=">_"}
protoc --version
~~~

~~~{.bash caption="Output"} 
libprotoc 3.19.4
~~~

Then I can use it to generate the go struct for the message type:

~~~{.bash caption=">_"}
 protoc activity-log/api/v1/*.proto \
    --go_out=. \
    --go_opt=paths=source_relative \
    --proto_path=.
~~~

~~~{.bash caption="Output"} 

Please specify a program using absolute path or make sure the program is available in your PATH system variable
--go_out: protoc-gen-go: Plugin failed with status code 1.
~~~

First it seems I need protoc-gen-go:

~~~{.bash caption=">_"}
$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.26
~~~

And I need to add it to my path:

~~~{.bash caption="~/.zshrc"}
export PATH="$PATH:$(go env GOPATH)/bin"
~~~

With that installed, I can successfully generate some code 

~~~{.bash caption=">_"}
 protoc activity-log/api/v1/*.proto \
    --go_out=. \
    --go_opt=paths=source_relative \
    --proto_path=.
~~~

And I get an activity struct that I can use in my service and client:

~~~{.go caption="api/v1/activity.pb.go"}
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.26.0
// 	protoc        v3.19.4
// source: activity-log/api/v1/activity.proto

package api_v1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
)

type Activity struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id          int32                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Time        *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=time,proto3" json:"time,omitempty"`
	Description string                 `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
}
~~~

`protoc` also generates a number of helper methods for working with the protobug message, such as field getters:

~~~{.go caption="api/v1/activity.pb.go"}
func (x *Activity) GetTime() *timestamppb.Timestamp {
	if x != nil {
		return x.Time
	}
	return nil
}

func (x *Activity) GetId() int32 {
	if x != nil {
		return x.Id
	}
	return 0
}
~~~

These are helping me correctly handle zero values on a nil Activity. I'm not sure why I'd be asking for the values of a nil Activity, but maybe it will make sense later.

Now that I have things working for one message type, I can define my whole service:

~~~{.protobuf caption="api/v1/activity.proto"}
service Activity_Log {
    rpc Insert(Activity) returns (InsertResponse) {}
    rpc Retrieve(RetrieveRequest) returns (Activity) {}
    rpc List(ListRequest) returns (Activities) {}
}

message RetrieveRequest {
    int32 id = 1;
}

message InsertResponse {
    int32 id = 1;
}

message ListRequest {
    int32 offset = 1;
}

message Activities {
    repeated Activity activities = 1;
}

message ActivityQuery {
	int32 offset = 1;
}
~~~

I can then generate the client and the service code using `protoc` again.

~~~{.bash caption=">_"}
 protoc activity-log/api/v1/*.proto \
    --go-grpc_out=. \
    --go-grpc_opt=paths=source_relative \
    --proto_path=.
~~~

Running this generates `activity_grpc.pb.go` with all the nessary code for a client and a server. 

Note how this time I used `go-grpc_out` and `go-grpc_opt=paths` instead of `go_out` and `go_opt=paths`. I can combine these two together to generate messages and the client server.  

~~~{.bash caption=">_"}
  protoc activity-log/api/v1/*.proto \
    --go_out=. \
    --go_opt=paths=source_relative \
    --go-grpc_out=. \
    --go-grpc_opt=paths=source_relative \
    --proto_path=.
~~~

<div class="notice">
**Side Note: OpenAPI Code Generation**

Generating code from an API specification is great, especially if you are working on a project where the client and server are being built by different people or even different teams.

In the past, when building REST clients in Scala, I've used OpenAPI specs as the source of truth and generated code from them, so the approach `protoc` is helping me use is not merely limited to gRPC. 

A great solution for writing REST clients from an OpenAPI definitions is [gaurdrail](https://github.com/guardrail-dev/guardrail) if you are using Scala. In goLang, gRPC seems much more common, but [go-swagger](https://github.com/go-swagger/go-swagger) looks pretty promising if you want a REST service.

Another possible path to generating a REST client is [grpc-gateway](https://github.com/grpc-ecosystem/grpc-gateway). If I need a rest endpoints in addition to the gRPC end-points, then I may give that a try.

</div>

## Golang gRPC Server

Now that I've got all my code generated, its time for me to build the server side.

Previously, in my http service, I had an `httpServer`:
~~~{.bash caption=">_"}
type httpServer struct {
	Activities *Activities
}
~~~

I'm going to rename that:
~~~{.bash caption=">_"}
type grpcServer struct {
	Activities *Activities
}
~~~

If you recall from when I was adding the `sqlite` feature, Activities handles all the data persistence. The data persistence should change at all. I just need to make sure I'm using my `protoc` generated struct. I can do this with an import change:

~~~{.diff caption="activity-log/internal/server/activity.go "}
import 
- api "github.com/adamgordonbell/cloudservices/activity-log"
+ api "github.com/adamgordonbell/cloudservices/activity-log/api/v1"
+ "google.golang.org/protobuf/types/known/timestamppb"
~~~

### `google.protobuf.Timestamp` and  `google.protobuf.Timestamp`

Previsouly my Activity struct was using `time.Time` to represent time and "net/http" was mapping it back and forth to a JSON string. However, protobufs are typed and so I have choosen to use `google.protobuf.Timestamp` as my datetime type. This means I need to worry less about getting invalid data.

Unfortunely, my generated code now uses a `google.protobuf.Timestamp` where my persistenance layer needs a `time.Time`. This is easy to fix with `AsTime`:

```
// AsTime converts x to a time.Time.
func (x *Timestamp) AsTime() time.Time {
	return time.Unix(int64(x.GetSeconds()), int64(x.GetNanos())).UTC()
}

```
And then I need to make an instance of it:

~~~{.bash caption=">_"}
func NewGRPCServer() *grpc.Server {
	var acc *Activities
	var err error
	if acc, err = NewActivities(); err != nil {
		log.Fatal(err)
	}
	gsrv := grpc.NewServer()
	srv := grpcServer{
		Activities: acc,
	}
	api.RegisterActivity_LogServer(gsrv, &srv)
	return gsrv
}
~~~
ToDO: explain why this returns grpc.Server

And then wire that up to my main method and I can start things up:
~~~{.bash caption=">_"}
func main() {
	log.Println("Starting listening on port 8080")
	port := ":8080"

	lis, err := net.Listen("tcp", port)
	if err != nil {
		log.Fatalf("failed to listen: %v", err)
	}
	log.Printf("Listening on %s", port)
	srv := server.NewGRPCServer()
	// Register reflection service on gRPC server.
	reflection.Register(srv)
	if err := srv.Serve(lis); err != nil {
		log.Fatalf("failed to serve: %v", err)
	}
}

~~~
I haven't actually hooked up an implementation of these methods yet, but I'm curious what happens if I run it. Actually I can't even get that far, it won't compile, but it does give me this helpful error message:

~~~{.bash caption=">_"}
# github.com/adamgordonbell/cloudservices/activity-log/internal/server
internal/server/server.go:30:39: cannot use &srv (type *grpcServer) as type api_v1.Activity_LogServer in argument to api_v1.RegisterActivity_LogServer:
        *grpcServer does not implement api_v1.Activity_LogServer (missing api_v1.mustEmbedUnimplementedActivity_LogServer method)

~~~
All I need to do is add an `UnimplementedActivity_LogServer`:
~~~{.bash caption=">_"}
type grpcServer struct {
	+ api.UnimplementedActivity_LogServer
	Activities *Activities
}
~~~

## Install 

## Just Notes

think about 
  - golang grpc rest api
   -- grpc gateway
  - golang grpc timeout
  - protoc golang grpc
  -
   - https://github.com/grpc-ecosystem/grpc-gateway


protoc



# Explain about protobufs
# Aside about json verification and golang

## CLI protobufs

start up a sample endpoint
~~~{.bash caption=">_"}
docker run -it --rm -p 9000:9000 -p 9001:9001 moul/grpcbin
~~~
Use grpc_cli
~~~{.bash caption=">_"}
brew install grpc 
==> Downloading from https://pkg-containers.githubusercontent.com/ghcr1/blobs/sha256:909f83d52b2fe4d9c2c2185183940162a4b2e189103d6f65a92b14714ec3abd6?se=2022-01-31T14%3A55%3A00Z&sig=HXzdw0%2BAyFd8%2FOYG
######################################################################## 100.0%
==> Installing dependencies for grpc: abseil, protobuf and re2
==> Installing grpc dependency: abseil
==> Pouring abseil--20211102.0.monterey.bottle.tar.gz
🍺  /usr/local/Cellar/abseil/20211102.0: 586 files, 6.9MB
==> Installing grpc dependency: protobuf
==> Pouring protobuf--3.19.4.monterey.bottle.tar.gz
🍺  /usr/local/Cellar/protobuf/3.19.4: 270 files, 19.6MB
==> Installing grpc dependency: re2
==> Pouring re2--20211101.monterey.bottle.tar.gz
🍺  /usr/local/Cellar/re2/20211101: 15 files, 448.6KB
==> Installing grpc
~~~

https://github.com/grpc/grpc/blob/master/doc/command_line_tool.md

Only for unsecured:
~~~{.bash caption=">_"}
grpc_cli ls localhost:9000  -l   

~~~

Or use `grpcurl`
~~~{.bash caption=">_"}
brew install grpcurl
grpcurl -plaintext localhost:9000 list
addsvc.Add
grpc.gateway.examples.examplepb.ABitOfEverythingService
grpc.reflection.v1alpha.ServerReflection
grpcbin.GRPCBin
hello.HelloService

~~~

See here:

https://grpc.io/docs/languages/go/quickstart/




## generate things

~~~{.bash caption=">_"}
protoc activity-log/api/v1/*.proto --go_out=. --go_opt=paths=source_relative --proto_path=.
~~~

## GRPC

here is how we generate it
~~~{.bash caption=">_"}
$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.1
~~~

## Problem:
~~~{.bash caption=">_"}
cannot use srv (variable of type *grpcServer) as api_v1.Activity_LogServer value in argument to api1.RegisterActivity_LogServer: missing method Insert
~~~
Solution: Adding UnImplemented
~~~{.bash caption=">_"}
type grpcServer struct {
	api1.UnimplementedActivity_LogServer
	Activities *Activities
}
~~~

~~~{.bash caption=">_"}

// UnimplementedActivity_LogServer must be embedded to have forward compatible implementations.
type UnimplementedActivity_LogServer struct {
}

func (UnimplementedActivity_LogServer) Insert(context.Context, *Activity) (*Activity, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedActivity_LogServer) Retrieve(context.Context, *RetrieveRequest) (*Activity, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Retrieve not implemented")
}
func (UnimplementedActivity_LogServer) List(context.Context, *ListRequest) (*Activities, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedActivity_LogServer) mustEmbedUnimplementedActivity_LogServer() {}
~~~

With this in place, I can make calls:
~~~{.bash caption=">_"}
grpcurl -plaintext -d '{ "id": 10 }' localhost:8080 api.v1.Activity_Log/Retrieve
ERROR:
  Code: Unimplemented
  Message: method Retrieve not implemented
~~~

GRPC has an introspection feature, that can be used to list what end points are available, but if I try it at first it fails:

~~~{.bash caption=">_"}
 grpcurl -plaintext localhost:8080 describe
Error: server does not support the reflection API
~~~
first you need to do this:
~~~{.bash caption=">_"}
https://github.com/grpc/grpc-go/blob/master/Documentation/server-reflection-tutorial.md
~~~

~~~{.bash caption=">_"}
 grpcurl -plaintext localhost:8080 describe
api.v1.Activity_Log is a service:
service Activity_Log {
  rpc Insert ( .api.v1.Activity ) returns ( .api.v1.Activity );
  rpc List ( .api.v1.ListRequest ) returns ( .api.v1.Activities );
  rpc Retrieve ( .api.v1.RetrieveRequest ) returns ( .api.v1.Activity );
}
grpc.reflection.v1alpha.ServerReflection is a service:
service ServerReflection {
  rpc ServerReflectionInfo ( stream .grpc.reflection.v1alpha.ServerReflectionRequest ) returns ( stream .grpc.reflection.v1alpha.ServerReflectionResponse );
}
~~~

`grpc_cli` which comes with grpc also works well for this
~~~{.bash caption=">_"}
grpc_cli ls localhost:8080 -l
filename: activity-log/api/v1/activity.proto
package: api.v1;
service Activity_Log {
  rpc Insert(api.v1.Activity) returns (api.v1.Activity) {}
  rpc Retrieve(api.v1.RetrieveRequest) returns (api.v1.Activity) {}
  rpc List(api.v1.ListRequest) returns (api.v1.Activities) {}
}

filename: reflection/grpc_reflection_v1alpha/reflection.proto
package: grpc.reflection.v1alpha;
service ServerReflection {
  rpc ServerReflectionInfo(stream grpc.reflection.v1alpha.ServerReflectionRequest) returns (stream grpc.reflection.v1alpha.ServerReflectionResponse) {}
}
~~~

Now I just have to implement this interface:

~~~{.bash caption=">_"}
// Activity_LogServer is the server API for Activity_Log service.
// All implementations must embed UnimplementedActivity_LogServer
// for forward compatibility
type Activity_LogServer interface {
	Insert(context.Context, *Activity) (*Activity, error)
	Retrieve(context.Context, *RetrieveRequest) (*Activity, error)
	List(context.Context, *ListRequest) (*Activities, error)
	mustEmbedUnimplementedActivity_LogServer()
}
~~~

not clear how `mustEmbedUnimplementedActivity_LogServer` works.



## Client

I was wondering how the client was going to work. How does the client code get generated, but actually its already been generated, and I can use it.

## Questions
 - when to use int, int32, uint64 ?
 - what about hte locks and the pointers and stuff


## Base stuff

This client here is helpful:
https://github.com/grpc/grpc-go/blob/master/examples/helloworld/greeter_client/main.go

First I have to connect to the client
~~~{.bash caption=">_"}

~~~

Then I can write my insert like this:
~~~{.bash caption=">_"}

~~~
and use it like this:
~~~{.bash caption=">_"}
~~~

Problem:
~~~{.bash caption=">_"}
go run cmd/client/main.go -get 3
Error: Insert failure: rpc error: code = Canceled desc = context canceled
exit status 1
~~~
Solution:
~~~{.bash caption=">_"}
I had called defer cancel in my constructor.
~~~

Problem:
~~~{.bash caption=">_"}
go run cmd/client/main.go -get 1
Error: Insert failure: rpc error: code = Canceled desc = grpc: the client connection is closing
exit status 1
~~~
Problem here was I closed the connection

# Error handling
By default your errors will only have a string description, but you
may want to include more information such as a status code or some other
arbitrary data.


We do this like this
NB: need code above this to not use status
~~~{.bash caption=">_"}
old:
return nil, fmt.Errorf("Internal Error: %w", err)

new:
		return nil, status.Error(codes.NotFound, "id was not found")

~~~

then we can unwrap it like this:
~~~{.bash caption=">_"}

~~~
