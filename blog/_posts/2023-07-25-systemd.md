---
title: "Let's Learn How Systemd Works"
categories:
  - Tutorials
toc: true
author: Josh

internal-links:
 - linux processes
 - init
 - systemd
 - linux boot
---

Before I decided to write this article, I knew systemd was the init process in Linux and that it was the process under which all other processes ran. I had run my share of `systemctl` commands, but truthfully, I just never really had the need to learn about it beyond that. I never really gave much thought to how systemd knew which processes to run, or really what else it could do. I just knew, you start a processes and somehow systemd takes over.

There are some really great reasources out there that go into deep detail about how systemd works, but what helped me start to understand it was setting it up to manage a service myself. In this tutorial, we'll take a simple golang program and set it up to run in the background with systemd. We'll ensure it restarts if it's killed and we'll also make sure systemd starts the process on boot. Doing so will allow us to take an in-depth tour of how systemd works and what features it offers.

## What is the Init Process?

In the world of Linux processes, the init processes is king. All other processes run beneath it. It's the first process to start after the kernal is loaded The init processes starts by initializing any processes needed to bring the machine to a functioning state. After that, it's responsible for starting and stopping process while thie system is running, as well as terminating processes safely when the system is shutdown.

<div class="notice">

  ## The Linux Boot Process

  The boot process from the time you press the power button to the time you are able to use your OS is extremely complicated. This article is going to focus on the point where systemd takes over and cover just some of things that happen from that point on. However, it's worth familiarizing yourself with what happens before systemd is even invoked. I found this chapter on [System Initialization](https://www.debian.org/doc/manuals/debian-reference/ch03.en.html) from the Debian website to be a good summary. It remains specific without getting bogged down in too much detail.

</div>

In older versions of Linux, the init process was a shell script. However, most modern Linux distros have replaced the shell script with a binary program called systemd[^1]. Systemd is a newer init system that is designed to improve performance and simplify service management. It uses configuration files known as units to define and manage services, and it provides advanced features like parallel service startup, socket activation, and on-demand service launching. It also manages logs. That's a lot for one program to do, which is why systemd is more than just a program, it's actually a suite of tools that work together. 

I should note that not all Linux distributions use Systemd, but many have made the switch. You should check which init processes your specific Linux version uses to be sure. 

Here's a list of a some popular Linux distributions that use systemd:

- Ubuntu 15.04 and later versions
- Debian 8 (Jessie) and later versions
- CentOS 7 and later versions
- RHEL 7 and later versions
- Fedora
- Arch Linux

## A Tour of Systemd

Let's take a quick tour of systemd and Linux processes.

I have an Amazon EC2 instance running Ubuntu 22.04.2 LTS. We can use `htop` to get a list of the all the running processes. Once in `htop`, pressing `t` will give a us a tree view so that we can see which processes are running under other processes.

<div class="wide">

![Tree view in htop]({{site.images}}{{page.slug}}/1.png)

</div>

Take a look at the top process, the one with process id (PID) 1, `/sbin/init`. It has PID 1 because it's the first process that started when we booted this instance of Linux. You'll also notice that in our tree view, all other processes exist in branches underneath `/sbin/init`.

But wait, I thought systemd was the init process? Let's go to `/sbin` and take a look.

```bash
ubuntu@#####:/sbin$ ls -lah | grep init
lrwxrwxrwx  1 root root 	20 Mar 20 14:32 init -> /lib/systemd/systemd

```
If we take a closer look at `init` we can see that it simply symlinks to `/lib/systemd/systemd`. So really, systemd is running all of our processes.


### Our Process

So that we can look at how to set up a process to be managed by systemd, we'll use this simple go program that prints "Hello World" every second.

```go
package main

import (
    	"fmt"
    	"time"
)

func main() {

    	for {
            	fmt.Println("Hello World")
            	time.Sleep(1 * time.Second)
    	}

}
```
The code and the executable are in my home directory.

```bash
ubuntu@ip-xxxx:~/hello-world$ ls
go.mod  hello-world  main.go
```
Let's run it.

```bash
ubuntu@ip-172-31-91-57:~/hello-world$ ./hello-world
Hello World
Hello World
Hello World
...
```

And while it's running, in a separate tab, we can open `htop`.

<div class="wide">

![Our hello world process running under bash]({{site.images}}{{page.slug}}/2.png)

</div>

This image is zoomed in, so we don't see the init process at the top, but it's still there, watching over everything. We can follow the tree down to ssh (which is how I'm connecting to the instance). Ssh has its own child processes it runs. Under one of those is our shell, bash, which is our enviorment where just ran hello-world. Then finally, under that, we have our `hello-world` process. (The presence of three child processes when running a simple Go program that prints a string is likely due to the way the Go runtime and the operating system handle certain aspects of process creation and management.)

Ok, we are done with the refresher course, on to systemd.

## What Are Systemd Units?

When we talk about long running processes in Linux, it's common to refer to them as services or daemons. Systemd calls them units. A systemd unit can be a service, like our hello world program, but it can also be other things such as sockets, mounts, or targets. (More on targets in a bit.)

Units are defined in unit files. A systemd unit file is a configuration file that defines various system components. Each unit file contains information about the unit's behavior, dependencies, startup conditions, and other settings needed for systemd to manage and supervise the corresponding system resource.

These unit files live in several different places. It's helpful to become familar

- Custom System Unit Files - `/etc/systemd/system/` :
Administrators can create custom system unit files to define new services or modify existing ones. Files in this directory take precedence over those in the system directories, allowing you to override or extend the default settings. This is where we will create our own unit file for our `hello-world` service.

- User-Specific Unit Files - `~/.config/systemd/user/ `:
User-specific unit files are used to manage services that are specific to individual users and their sessions. Each user can create and manage their own user units.

- Standard Unit Files - `/lib/systemd/system/`:
Unit files for system wide units. These are the usually related to units that come preinstalled by the distro maintainers.

- Installed Package Unit Files - `/usr/lib/systemd/system`:
Generally this is where your package manager will put unit files for installed packages. This will happen automatically as part of the install process. For example, nginx puts several unit files here after it is installed.


### How to Create Your Own Systemd Unit

Ok. So now we can create our own systemd unit file to manage our `hello-world` process. Create a file called `/etc/systemd/system/hello-world.service`.

```text
[Unit]
Description=Hello World Service

[Service]
ExecStart=/home/ubuntu/hello-world/hello-world

[Install]
WantedBy=multi-user.target
```

Most interesting here is the `ExecStart`, which simple gives the path to the program we want systemd to be able to start and manage, and `WantedBy`. `WantedBy` let's us set up any dependencies our program will need to run. We could use this to declare another service, but it's also common to declare a target. Targets are groups of units and they are are often used to specify certain states you may want your system to be in. In this case, setting the `multi-user.target` ensures the system is in a state were we have a multi user environment that can be interacted with. Declaring it here is telling systemd that it should start our process only after it has successfully started all the processes listed in the `multi-user.target`.

What the hell are those, you ask? Let's see! Targets are another form of unit that systemd can manage, and they are configured the same way as our service, in a unit file. We can find the unit file for the multi-user target at `/lib/systemd/system/multi-user.target`, but that's not going to give us what we want. To see all the dependencies for the multi-user target, we can run:

```bash
ubuntu@ip-172-31-91-57:~$ sudo systemctl list-dependencies multi-user.target
multi-user.target
● ├─apport.service
● ├─chrony.service
● ├─console-setup.service
● ├─cron.service
● ├─dbus.service
○ ├─dmesg.service
○ ├─e2scrub_reap.service
○ ├─ec2-instance-connect.service
○ ├─grub-common.service
○ ├─grub-initrd-fallback.service
○ ├─hibinit-agent.service
○ ├─irqbalance.service
○ ├─lxd-agent.service
● ├─networkd-dispatcher.service
○ ├─open-vm-tools.service
● ├─plymouth-quit-wait.service
● ├─plymouth-quit.service
....
```

This output is cut off to save space, but hopefully you get the idea.

Just creating this file won't get systemd to start managing our program. We'll need to do two more steps. First, we need to get systemd to read our new `.service` unit file. We can do that with:

```bash
systemctl daemon-reload
```
This tells systemd to reread all the unit files. Now that our file is loaded, we can take check the status of our service.

```bash
ubuntu@ip-172-31-91-57:/etc/systemd/system$ sudo systemctl status hello-world
○ hello-world.service - Hello World Service
 	Loaded: loaded (/etc/systemd/system/hello-world.service; enabled; vendor preset: enabled)
 	Active: inactive (dead)
```

Right now our service is inactive. So let's start it up and then check the status again.

enable it will start up when the system starts

```bash
ubuntu@ip-172-31-91-57:/etc/systemd/system$ sudo systemctl start hello-world
ubuntu@ip-172-31-91-57:/etc/systemd/system$ sudo systemctl status hello-world
● hello-world.service - Hello World Service
 	Loaded: loaded (/etc/systemd/system/hello-world.service; enabled; vendor preset: enabled)
 	Active: active (running) since Thu 2023-07-20 20:51:37 UTC; 14s ago
   Main PID: 179038 (hello-world)
  	Tasks: 3 (limit: 1141)
 	Memory: 564.0K
    	CPU: 3ms
 	CGroup: /system.slice/hello-world.service
         	└─179038 /home/ubuntu/hello-world/hello-world


Jul 20 20:51:42 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 20 20:51:43 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 20 20:51:44 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 20 20:51:45 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 20 20:51:46 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 20 20:51:47 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 20 20:51:48 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 20 20:51:49 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 20 20:51:50 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 20 20:51:51 ip-172-31-91-57 hello-world[179038]: Hello World
```

Notice how the status of Active has switched from inactive (dead) to active (running). Also notice that below the status info, we get the last ten lines of the log. We'll talk more about logs in another section. For now, let's check `htop` again and take a look at where our `hello-world` process shows up on the tree.

<div class="wide">

![Our hello world process running under systemd]({{site.images}}{{page.slug}}/3.png)

</div>

We can see here that instead of showing up under bash, where we ran the process from before, it now shows up as a direct child of `/sbin/init`, which is systemd.

We can also see that if check the dependencies for multi-user target again:

```bash
ubuntu@ip-172-31-91-57:~$ sudo systemctl list-dependencies multi-user.target
multi-user.target
● ├─apport.service
● ├─chrony.service
● ├─console-setup.service
● ├─cron.service
● ├─dbus.service
○ ├─dmesg.service
○ ├─e2scrub_reap.service
○ ├─ec2-instance-connect.service
○ ├─grub-common.service
○ ├─grub-initrd-fallback.service
● ├─hello-world.service
○ ├─hibinit-agent.service
○ ├─irqbalance.service
○ ├─lxd-agent.service
● ├─networkd-dispatcher.service
○ ├─open-vm-tools.service
● ├─plymouth-quit-wait.service
● ├─plymouth-quit.service
....
```

Hey, check it out, the 11th in the list is our `hello-world.service`!  

{% include_html cta/bottom-cta.html %}

[^1]: It's important to mention right away that there was a lot of [controversy](https://lwn.net/Articles/698822/) about the switch to systemd and that I do not care.



- [ ] Run mark down linter (`lint`)
- [ ] Run `link-opp` and find 1-5 places to incorporate links to other articles
