---
title: "Let's Learn How Systemd Works"
categories:
  - Tutorials
toc: true
author: Josh

internal-links:
 - linux processes
 - init
 - systemd
 - linux boot
---

It's incredible to me how long I used linux before really understanding how systemd works. Truthfully, I still a novice. Before taking a deeper dive recently, I knew systemd was the init process and that it was the process under which all other processes ran. I had run my share of systemctl commands, but truthfully, I just never really had the need to learn about it beyond that. I never really gave much thought to how systemd knew which processes to run, or really what else it could do. I just sort of nievely figured, you start a processes and somehow systemd takes over.

There are some really great reasources out there that go into deep detail about how systemd works, but what really helped me start to understand it on a deeper level was setting it up to manage a service myself. In this tutorial, we'll take a simple golang program and set it up to run in the background with systemd. We'll ensure it restarts if it's killed and we'll also make sure systemd starts the process on boot.

By doing so, we'll take a more indepth tour of how systemd works and what features it offers.

In the world of Linux processes, the init processes is king. All other processes run beneath it. It's the first process to start after the kernal, and it's job is to start and stop processes. The init processes starts by initializing any processes needed to bring the machine to a functioning state.

In older versions of Linux, this init process was a shell script. However, most modern Linux distros have replaced the shell script with a binary program called Systemd.[^1] Systemd is a newer init system that is designed to improve performance and simplify service management. systemd uses configuration files known as units to define and manage services, and it provides advanced features like parallel service startup, socket activation, and on-demand service launching.

Some Linux distributions that use systemd:
- Ubuntu 15.04 and later versions
- Debian 8 (Jessie) and later versions
- CentOS 7 and later versions
- RHEL 7 and later versions
- Fedora
- Arch Linux

There's a lot of great tutorials out there about how to user Systemd. It's a powerful set of tools that can do a lot. What I want to do in this tutorial is take you on a tour of systemd and, at the same time, interact with it in a tangible way. This way you can get a feel for how it works and hopefully begin to understand how it a bit deeper.


<div class="notice">

  ## The Linux Boot Process

  The boot process from the time you press the power button to the time you are able to use your OS is extremely complicated. This article is going to focus on the point where systemd takes over and walk through what happens from that point on. However, it's worth familiarizing yourself with what happens before systemd is even invoked. I found this chapter on [System Initialization](https://www.debian.org/doc/manuals/debian-reference/ch03.en.html) from the Debian website to be a good summary. It remains specific without getting bogged down in too much detail.

</div>


## A Tour of Systemd

I have an Amazon EC2 instance running Ubuntu 22.04.2 LTS. We can use `htop` to get a list of the all the running processes. Once in `htop`, pressing `t` will give a us a tree view so that we can see which processes are running under other processes.

<div class="wide">

![Tree view in htop]({{site.images}}{{page.slug}}/1.png)

</div>

Take a look at the top process, the one with PID 1, `/sbin/init`. It has PID 1 because it's the first process that started when we booted this instance of Linux. You'll also notice that in our tree view, all other processes exist in branches underneath `/sbin/init`.

But wait, I thought we abandoned init for systemd? Let's go to `/sbin` and take a look.

```bash
ubuntu@#####:/sbin$ ls -lah | grep init
lrwxrwxrwx  1 root root 	20 Mar 20 14:32 init -> /lib/systemd/systemd

```
If we take a closer look at `init` we can see that it simply symlinks to `/lib/systemd/systemd`. So really, systemd is running all of our processes.


## Our Process

So that we can look at how to set up a process to be managed by systemd, we'll use this simple go program that prints Hello World every second.

```go
package main

import (
    	"fmt"
    	"time"
)

func main() {

    	for {
            	fmt.Println("Hello World")
            	time.Sleep(1 * time.Second)
    	}

}
```
The code and the executable are in my home directory.

```bash
ubuntu@ip-xxxx:~/hello-world$ ls
go.mod  hello-world  main.go
```
Let's run it.

```bash
ubuntu@ip-172-31-91-57:~/hello-world$ ./hello-world
Hello World
Hello World
Hello World
...
```

And while it's running, in a separate tab, we can open `htop`.

<div class="wide">

![Our hello world process running under bash]({{site.images}}{{page.slug}}/2.png)

</div>

This image is zoomed in, so we don't see the init process at the top, but it's still there, watching over everything. We can follow the tree down to ssh (how I'm connecting to the instance). ssh has it's own child processes it runs. Under one of those is our shell, bash. Then finally, under that, we have our `hello-world` process. (The presence of three child processes when running a simple Go program that prints a string is likely due to the way the Go runtime and the operating system handle certain aspects of process creation and management.)

I know what you're thinking. Big deal. I get that. Let's move on.


## What Are Systemd Units?

We may define long running processes as services or daemons. Systemd calls them units. A systemd unit can be a process, like our hello world program, but it can also be other things managed by systemd, such as sockets, mounts, or targets.

Resources that are managed by systemd are called Units. We can tell systemd to manage our `hello-world` process by creating a unit file.

A systemd unit file is a configuration file that defines various system components. Each unit file contains information about the unit's behavior, dependencies, startup conditions, and other settings needed for systemd to manage and supervise the corresponding system resource.

These unit files live in several different places.

- Custom System Unit Files:
Administrators can create custom system unit files to define new services or modify existing ones. These custom unit files should be placed in the /etc/systemd/system/ directory. Files in this directory take precedence over those in the system directories, allowing you to override or extend the default settings.

- User-Specific Unit Files:
User-specific unit files are used to manage services that are specific to individual users and their sessions. They are stored in the ~/.config/systemd/user/ directory. Each user can create and manage their own user units.

- Systemd Unit Include Directories:
Systemd provides several directories where additional configuration files can be placed, and all unit files found in these directories are included automatically. Some of these directories include:
	/etc/systemd/system/*.wants/: Symbolic links to unit files placed in this directory will result in the linked units being enabled when the corresponding target is started.
	/etc/systemd/system/*.requires/: Symbolic links to unit files placed in this directory will make the linked units a requirement for the corresponding target.
	/run/systemd/system/: This directory contains temporary runtime unit files created by applications and is typically managed by systemd itself.


### How to Create Your Own Systemd Unit

Ok. So now we can create our own systemd unit file to manage our `hello-world` process. We can put custom unit files in `/etc/systemd/system/`. Create a file called `hello-world.service`.

```text
[Unit]
Description=Hello World Service

[Service]
ExecStart=/home/ubuntu/hello-world/hello-world

[Install]
WantedBy=multi-user.target
```

Most interesting here is the `ExecStart`, which simple gives the path to the program we want systemd to be able to start and manage, and `WantedBy`. `WantedBy` let's us set up any dependencies our program will need to run. We could use this to declare another service, but it's also common to declare a target. Targets are groups of units and they are are often used to specify certain states you may want your system to be in. In this case, setting the `multi-user.target` ensures the system is in a state were we have a multi user enviorment that can be interacted with. Declaring it here is telling systemd that it should start our process only after it has successfully started all the processes listed in the `multi-user.target`.

What the hell are those, you ask? Let's see! Targets are another form of unit that systemd can manage, and they are configured the same way as our service, in a unit file. We can find the unit file for the multi-user target at `/lib/systemd/system/multi-user.target`, but that's not going to give us what we want. To see all the dependancies for the multi-user target, we can run:

```bash
ubuntu@ip-172-31-91-57:~$ sudo systemctl list-dependencies multi-user.target
multi-user.target
● ├─apport.service
● ├─chrony.service
● ├─console-setup.service
● ├─cron.service
● ├─dbus.service
○ ├─dmesg.service
○ ├─e2scrub_reap.service
○ ├─ec2-instance-connect.service
○ ├─grub-common.service
○ ├─grub-initrd-fallback.service
○ ├─hibinit-agent.service
○ ├─irqbalance.service
○ ├─lxd-agent.service
● ├─networkd-dispatcher.service
○ ├─open-vm-tools.service
● ├─plymouth-quit-wait.service
● ├─plymouth-quit.service
....
```

This output is cut off to save space, but hopefully you get the idea.

Just creating this file won't get systemd to start managing our program. We'll need to do two more steps. First, we need to get systemd to read our new `.service` unit file. We can do that with:

```bash
systemctl daemon-reload
```
This tells systemd to reread all the unit files. Now that our file is loaded, we can take check the status of our service.

```bash
ubuntu@ip-172-31-91-57:/etc/systemd/system$ sudo systemctl status hello-world
○ hello-world.service - Hello World Service
 	Loaded: loaded (/etc/systemd/system/hello-world.service; enabled; vendor preset: enabled)
 	Active: inactive (dead)
```

Right now our service is inactive. So let's start it up and then check the status again.

enable it will start up when the system starts

```bash
ubuntu@ip-172-31-91-57:/etc/systemd/system$ sudo systemctl start hello-world
ubuntu@ip-172-31-91-57:/etc/systemd/system$ sudo systemctl status hello-world
● hello-world.service - Hello World Service
 	Loaded: loaded (/etc/systemd/system/hello-world.service; enabled; vendor preset: enabled)
 	Active: active (running) since Thu 2023-07-20 20:51:37 UTC; 14s ago
   Main PID: 179038 (hello-world)
  	Tasks: 3 (limit: 1141)
 	Memory: 564.0K
    	CPU: 3ms
 	CGroup: /system.slice/hello-world.service
         	└─179038 /home/ubuntu/hello-world/hello-world


Jul 20 20:51:42 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 20 20:51:43 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 20 20:51:44 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 20 20:51:45 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 20 20:51:46 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 20 20:51:47 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 20 20:51:48 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 20 20:51:49 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 20 20:51:50 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 20 20:51:51 ip-172-31-91-57 hello-world[179038]: Hello World
```

Notice how the status of Active has switched from inactive (dead) to active (running). Also notice that below the status info, we get the last ten lines of the log. We'll talk more about logs in another section. For now, let's check `htop` again and take a look at where our `hello-world` process shows up on the tree.

<div class="wide">

![Our hello world process running under systemd]({{site.images}}{{page.slug}}/3.png)

</div>

We can see here that instead of showing up under bash, where we ran the process from before, it now shows up as a direct child of `/sbin/init`, which is systemd.

We can also see that if check the dependancies for multi-user target again:

```bash
ubuntu@ip-172-31-91-57:~$ sudo systemctl list-dependencies multi-user.target
multi-user.target
● ├─apport.service
● ├─chrony.service
● ├─console-setup.service
● ├─cron.service
● ├─dbus.service
○ ├─dmesg.service
○ ├─e2scrub_reap.service
○ ├─ec2-instance-connect.service
○ ├─grub-common.service
○ ├─grub-initrd-fallback.service
● ├─hello-world.service
○ ├─hibinit-agent.service
○ ├─irqbalance.service
○ ├─lxd-agent.service
● ├─networkd-dispatcher.service
○ ├─open-vm-tools.service
● ├─plymouth-quit-wait.service
● ├─plymouth-quit.service
....
```

Hey, check it out, the 11th in the list is our `hello-world.service`!  

{% include_html cta/cta2.html %}

[^1]: It's important to mention right away that there was a lot of [controversy](https://lwn.net/Articles/698822/) about the switch to systemd and that I do not care.

### Writing Article Checklist

- [ ] Write Outline
- [ ] Write Draft
- [ ] Fix Grammarly Errors
- [ ] Read out loud
- [ ] Write 5 or more titles and pick the best on
- [ ] First two paragraphs: What's it about? Why listen to you?
- [ ] Create header image in Canva
- [ ] Optional: Find ways to break up content with quotes or images
- [ ] Verify look of article locally
- [ ] Run mark down linter (`lint`)
- [ ] Add keywords for internal links to front-matter
- [ ] Run `link-opp` and find 1-5 places to incorporate links to other articles
- [ ] Raise PR
