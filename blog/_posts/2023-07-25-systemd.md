---
title: "Let's Learn How Systemd Works"
categories:
  - Tutorials
toc: true
author: Josh

internal-links:
 - linux processes
 - init
 - systemd
 - linux boot
---

Before I decided to write this article, I knew systemd was the init process in Linux and that it was the process under which all other processes ran. I had run my share of `systemctl` commands, but truthfully, I just never really had the need to learn about it beyond that. I never really gave much thought to how systemd knew which processes to run, or really what else it could do. I just knew, you start a processes and somehow systemd takes over.

There are some really great resources out there that go into deep detail about how systemd works, but what helped me start to understand it was setting it up to manage a service myself. In this tutorial, we'll take a simple golang program and set it up to run in the background with systemd. We'll ensure it restarts if it's killed and we'll also make sure systemd starts the process on boot. Doing so will allow us to take an in-depth tour of how systemd works and what features it offers.

## What is the Init Process?

In the world of Linux processes, the init processes is king. All other processes run beneath it. It's the first process to start after the kernel is loaded The init processes starts by initializing any processes needed to bring the machine to a functioning state. After that, it's responsible for starting and stopping process while the system is running, as well as terminating processes safely when the system is shutdown.

<div class="notice">

## The Linux Boot Process

  The boot process from the time you press the power button to the time you are able to use your OS is extremely complicated. This article is going to focus on the point where systemd takes over and cover just some of things that happen from that point on. However, it's worth familiarizing yourself with what happens before systemd is even invoked. I found this chapter on [System Initialization](https://www.debian.org/doc/manuals/debian-reference/ch03.en.html) from the Debian website to be a good summary. It remains specific without getting bogged down in too much detail.

</div>

In older versions of Linux, the init process was a shell script. However, most modern Linux distros have replaced the shell script with a binary program called systemd[^1]. Systemd is a newer init system that is designed to improve performance and simplify service management. It uses configuration files known as units to define and manage services, and it provides advanced features like parallel service startup, socket activation, and on-demand service launching. It also manages logs. That's a lot for one program to do, which is why systemd is more than just a program, it's actually a suite of tools that work together.

I should note that not all Linux distributions use Systemd, but many have made the switch. You should check which init processes your specific Linux version uses to be sure.

Here's a list of a some popular Linux distributions that use systemd:

- Ubuntu 15.04 and later versions
- Debian 8 (Jessie) and later versions
- CentOS 7 and later versions
- RHEL 7 and later versions
- Fedora
- Arch Linux

## A Tour of Systemd

Let's take a quick tour of systemd and Linux processes.

I have an Amazon EC2 instance running Ubuntu 22.04.2 LTS. We can use `htop` to get a list of the all the running processes. Once in `htop`, pressing `t` will give a us a tree view so that we can see which processes are running under other processes.

<div class="wide">

![Tree view in htop]({{site.images}}{{page.slug}}/1.png)

</div>

Take a look at the top process, the one with process id (PID) 1, `/sbin/init`. It has PID 1 because it's the first process that started when we booted this instance of Linux. You'll also notice that in our tree view, all other processes exist in branches underneath `/sbin/init`.

But wait, I thought systemd was the init process? Let's go to `/sbin` and take a look.

~~~{.bash caption=">_"}

ubuntu@ip-xxxx:/sbin$ ls -lah | grep init
lrwxrwxrwx  1 root root     20 Mar 20 14:32 init -> /lib/systemd/systemd

~~~

If we take a closer look at `init` we can see that it simply symlinks to `/lib/systemd/systemd`. So really, systemd is running all of our processes.

### Our Process

So that we can look at how to set up a process to be managed by systemd, we'll use this simple go program that prints "Hello World" every second.

~~~{.go caption="main.go"}
package main

import (
        "fmt"
        "time"
)

func main() {

        for {
                fmt.Println("Hello World")
                time.Sleep(1 * time.Second)
        }

}
~~~

The code and the executable are in my home directory.

~~~{.bash caption=">_"}

ubuntu@ip-xxxx:~/hello-world$ ls
go.mod  hello-world  main.go
~~~

Let's run it.

~~~{.bash caption=">_"}

ubuntu@ip-xxxx:~/hello-world$ ./hello-world
Hello World
Hello World
Hello World
...
~~~

And while it's running, in a separate tab, we can open `htop`.

<div class="wide">

![Our hello world process running under bash]({{site.images}}{{page.slug}}/2.png)

</div>

This image is zoomed in, so we don't see the init process at the top, but it's still there, watching over everything. We can follow the tree down to ssh (which is how I'm connecting to the instance). Ssh has its own child processes it runs. Under one of those is our shell, bash, which is our enviorment where just ran hello-world. Then finally, under that, we have our `hello-world` process. (The presence of three child processes when running a simple Go program that prints a string is likely due to the way the Go runtime and the operating system handle certain aspects of process creation and management.)

Ok, we are done with the refresher course, on to systemd.

## What Are Systemd Units?

When we talk about long running processes in Linux, it's common to refer to them as services or daemons. Systemd calls them units. A systemd unit can be a service, like our hello world program, but it can also be other things such as sockets, mounts, or targets. (More on targets in a bit.)

Units are defined in unit files. A systemd unit file is a configuration file that defines various system components. Each unit file contains information about the unit's behavior, dependencies, startup conditions, and other settings needed for systemd to manage and supervise the corresponding system resource.

These unit files live in several different places. It's helpful to become familar

- Custom System Unit Files - `/etc/systemd/system/` :
Administrators can create custom system unit files to define new services or modify existing ones. Files in this directory take precedence over those in the system directories, allowing you to override or extend the default settings. This is where we will create our own unit file for our `hello-world` service.

- User-Specific Unit Files - `~/.config/systemd/user/`:
User-specific unit files are used to manage services that are specific to individual users and their sessions. Each user can create and manage their own user units.

- Standard Unit Files - `/lib/systemd/system/`:
Unit files for system wide units. These are the usually related to units that come preinstalled by the distro maintainers.

- Installed Package Unit Files - `/usr/lib/systemd/system`:
Generally this is where your package manager will put unit files for installed packages. This will happen automatically as part of the install process. For example, nginx puts several unit files here after it is installed.

### How to Create Your Own Systemd Unit

So now we can create our own systemd unit file to manage our `hello-world` process. Create a file called `/etc/systemd/system/hello-world.service`.

~~~{.text caption="hello-world.service"}
[Unit]
Description=Hello World Service

[Service]
ExecStart=/home/ubuntu/hello-world/hello-world

[Install]
WantedBy=multi-user.target
~~~

Most interesting here is the `ExecStart`, which tells systemd how to start our service, and `WantedBy`. `WantedBy` let's us set up any dependencies our program will need to run. We could use this to declare another service, but it's also common to declare a target. Targets are groups of units and they are often used to specify certain states you may want your system to be in. Similar to runtimes in Unix. In this case, setting the `multi-user.target` ensures the system is in a state were we have a multi user environment that can be interacted with. Declaring it here is telling systemd that it should start our process only after it has successfully started all the processes listed in the `multi-user.target`.

What the hell are those, you ask? Let's see! Targets are another form of unit that systemd can manage, and they are configured the same way as our service, in a unit file. We can find the unit file for the multi-user target at `/lib/systemd/system/multi-user.target`, but that's not going to show us all the dependencies, since they won't all be declared in one file. To see all the dependencies for the multi-user target (or any unit), we can run:

~~~{.bash caption=">_"}

ubuntu@ip-xxxx:~$ sudo systemctl list-dependencies multi-user.target
multi-user.target
● ├─apport.service
● ├─chrony.service
● ├─console-setup.service
● ├─cron.service
● ├─dbus.service
○ ├─dmesg.service
○ ├─e2scrub_reap.service
○ ├─ec2-instance-connect.service
○ ├─grub-common.service
○ ├─grub-initrd-fallback.service
○ ├─hibinit-agent.service
○ ├─irqbalance.service
○ ├─lxd-agent.service
● ├─networkd-dispatcher.service
○ ├─open-vm-tools.service
● ├─plymouth-quit-wait.service
● ├─plymouth-quit.service
....
~~~

This output is cut off to save space, but hopefully you get the idea. Notice we don't see our `hello-world` program listed yet. We're getting there.

Just creating the unit file won't get systemd to start managing our program. We'll need to do two more steps. First, we need to get systemd to read our new `.service` unit file. We can do that with:

~~~{.bash caption=">_"}
systemctl daemon-reload
~~~

This tells systemd to reread all the unit files. Now that systemd knows about our unit, we can check the status of our service.

~~~{.bash caption=">_"}

ubuntu@ip-xxxx:/etc/systemd/system$ sudo systemctl status hello-world
○ hello-world.service - Hello World Service
     Loaded: loaded (/etc/systemd/system/hello-world.service; enabled; vendor preset: enabled)
     Active: inactive (dead)
~~~

<div class="notice">

## Disabled Vs Inactive

Systemd units have two states that can be set. They sound very similar, but they refere to two different things. It's important to understand the difference.

Enabled/Disabled: TLDR; Can systemd automatically start this unit?

In the second line of output, toward the end of the line, you'll notice your unit will have a status of either enabled or disabled. This simply indicates whether or not systemd can automatically start the unit. You may have this unit set to start on boot, or it may be a dependancy of another unit that wants to start it. If your unit is set to disabled, then systemd won't be able to start it in both of those cases.

Active/Inactive: TLDR; Is the unit running.

When a service unit is inactive, it means that the unit is not currently running or actively providing its services. However, this does not necessarily mean that the unit is permanently disabled. An inactive unit might still be enabled and can be started when needed.

</div>

Right now our service is inactive. So let's start it up and then check the status again.

~~~{.bash caption=">_"}

ubuntu@ip-xxxx:/etc/systemd/system$ sudo systemctl status hello-world
● hello-world.service - Hello World Service
     Loaded: loaded (/etc/systemd/system/hello-world.service; enabled; vendor preset: enabled)
     Active: active (running) since Thu 2023-07-20 20:51:37 UTC; 14s ago
   Main PID: 179038 (hello-world)
      Tasks: 3 (limit: 1141)
     Memory: 564.0K
        CPU: 3ms
     CGroup: /system.slice/hello-world.service
             └─179038 /home/ubuntu/hello-world/hello-world


Jul 20 20:51:42 ip-xxxx hello-world[179038]: Hello World
Jul 20 20:51:43 ip-xxxx hello-world[179038]: Hello World
Jul 20 20:51:44 ip-xxxx hello-world[179038]: Hello World
Jul 20 20:51:45 ip-xxxx hello-world[179038]: Hello World
Jul 20 20:51:46 ip-xxxx hello-world[179038]: Hello World
Jul 20 20:51:47 ip-xxxx hello-world[179038]: Hello World
Jul 20 20:51:48 ip-xxxx hello-world[179038]: Hello World
Jul 20 20:51:49 ip-xxxx hello-world[179038]: Hello World
Jul 20 20:51:50 ip-xxxx hello-world[179038]: Hello World
Jul 20 20:51:51 ip-xxxx hello-world[179038]: Hello World
~~~

Notice how the status of Active has switched from inactive (dead) to active (running). Also notice that below the status info, we get the last ten lines of the log, which is pretty cool. Let's check `htop` again and take a look at where our `hello-world` process shows up on the tree.

<div class="wide">

![Our hello world process running under systemd]({{site.images}}{{page.slug}}/3.png)

</div>

We can see here that instead of showing up under bash, where we ran the process from before, it now shows up as a direct child of `/sbin/init`, which is systemd.

We can also see that if check the dependencies for multi-user target again:

~~~{.bash caption=">_"}

ubuntu@ip-xxxx:~$ sudo systemctl list-dependencies multi-user.target
multi-user.target
● ├─apport.service
● ├─chrony.service
● ├─console-setup.service
● ├─cron.service
● ├─dbus.service
○ ├─dmesg.service
○ ├─e2scrub_reap.service
○ ├─ec2-instance-connect.service
○ ├─grub-common.service
○ ├─grub-initrd-fallback.service
● ├─hello-world.service
○ ├─hibinit-agent.service
○ ├─irqbalance.service
....
~~~

Hey, check it out, the 11th in the list is our `hello-world.service`! This is great. Now our service is running in the background. What happens if we kill it?

~~~{.bash caption=">_"}

ubuntu@ip-172-31-91-57:~$ sudo kill 179038
~~~

Our unit becomes inactive, as we would expect. We can also see where it was deactivated in the logs.

~~~{.bash caption=">_"}

○ hello-world.service - Hello World Service
     Loaded: loaded (/etc/systemd/system/hello-world.service; enabled; vendor preset: enabled)
     Active: inactive (dead) since Mon 2023-07-24 19:18:25 UTC; 1min 41s ago
    Process: 179038 ExecStart=/home/ubuntu/hello-world/hello-world (code=killed, signal=TERM)
    Main PID: 179038 (code=killed, signal=TERM)
        CPU: 39.210s

Jul 24 19:18:18 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 24 19:18:19 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 24 19:18:20 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 24 19:18:21 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 24 19:18:22 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 24 19:18:23 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 24 19:18:24 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 24 19:18:25 ip-172-31-91-57 hello-world[179038]: Hello World
Jul 24 19:18:25 ip-172-31-91-57 systemd[1]: hello-world.service: Deactivated successfully.
Jul 24 19:18:25 ip-172-31-91-57 systemd[1]: hello-world.service: Consumed 39.210s CPU time.
~~~

Also notice where it says `Main PID: 179038 (code=killed, signal=TERM)`. Systemd knows that the process was killed.

But what if we want the service to always be running? In that case, we can tell systemd it should restart the service when it dies. All we need to do is update our unit file.

We've got two options for telling systemd when to restart our service. 

~~~{.text caption="hello-world.service"}
[Unit]
Description=Hello World Service

[Service]
ExecStart=/home/ubuntu/hello-world/hello-world
Restart=always

[Install]
WantedBy=multi-user.target
~~~

Now lets start our service back up.

~~~{.bash caption=">_"}

ubuntu@ip-172-31-91-57:~$ sudo systemctl start hello-world
Warning: The unit file, source configuration file or drop-ins of hello-world.service changed on disk. Run 'systemctl daemon-reload' to reload units.

~~~

Seems like systemd detected that our file had changed. That's cool. We just follow the instructions in teh error to get systemd to reread the unit file.

I'm not totally sure this is necessary in all cases, but I'm also going to restart the service.

~~~{.bash caption=">_"}

ubuntu@ip-172-31-91-57:~$ sudo systemctl restart hello-world
~~~

Now if you check the status of the service again, it should be active. So let's kill it.

~~~{.bash caption=">_"}

ubuntu@ip-172-31-91-57:~$ sudo kill 190646
~~~

And check the status again. It's still active, but that's because systemd restarted it faster than we could check the status and see that it was deactivated. No worries though because we can see right in the logs when the unit was stopped and when it was started back up again.

~~~{.bash caption=">_"}

ubuntu@ip-172-31-91-57:~$ sudo systemctl status hello-world
● hello-world.service - Hello World Service
     Loaded: loaded (/etc/systemd/system/hello-world.service; enabled; vendor preset: enabled)
     Active: active (running) since Mon 2023-07-24 19:43:23 UTC; 2s ago
   Main PID: 190658 (hello-world)
      Tasks: 3 (limit: 1141)
     Memory: 572.0K
        CPU: 1ms
     CGroup: /system.slice/hello-world.service
             └─190658 /home/ubuntu/hello-world/hello-world

Jul 24 19:43:23 ip-172-31-91-57 systemd[1]: hello-world.service: Scheduled restart job, restart counter is at 1.
Jul 24 19:43:23 ip-172-31-91-57 systemd[1]: Stopped Hello World Service.
Jul 24 19:43:23 ip-172-31-91-57 hello-world[190658]: Hello World
Jul 24 19:43:23 ip-172-31-91-57 systemd[1]: Started Hello World Service.
Jul 24 19:43:24 ip-172-31-91-57 hello-world[190658]: Hello World
Jul 24 19:43:25 ip-172-31-91-57 hello-world[190658]: Hello World
~~~

## Journalctl

We could do a whole other blog post on journalctl, but I do want to mention it here briefly as it can be one of the great advantages of using systemd.



## Conclusion

In this tutorial, we explored the basics of using systemd units in Linux. Understanding systemd is essential for any Linux user, as it plays a central role in managing services, tasks, and system initialization. By learning how to create and manage systemd units, you gain the ability to control services and customize their behavior effectively, leading to a more efficient and reliable system.

To deepen your understanding of systemd, there are several topics worth exploring. First, you can delve into how systemd handles dependencies between units. Understanding dependencies ensures that services start in the correct order and that your system functions smoothly.

Next, learning more about systemd targets will help you grasp the concept of grouping units and how they can be used to achieve specific system states or goals. Targets are powerful tools for managing the system's behavior during boot-up or when switching between different system modes.

To see practical examples of systemd unit files for popular services, consider examining existing unit files for services like SSH or Nginx. Studying these files will provide insights into how experienced administrators configure and manage these critical services using systemd.

In conclusion, mastering systemd empowers you to take full control of your Linux system, optimize performance, and ensure the reliable operation of services. By continuing your exploration of systemd's features and studying real-world unit files, you'll become a more proficient Linux user, capable of tailoring your system to suit your specific needs and requirements. Embrace the power of systemd, and it will serve you well on your Linux journey. Happy learning!



{% include_html cta/bottom-cta.html %}

[^1]: It's important to mention right away that there was a lot of [controversy](https://lwn.net/Articles/698822/) about the switch to systemd and that I do not care.
